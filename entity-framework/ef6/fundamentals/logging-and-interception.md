---
title: Protokolování a zachycení databázových operací – EF6
author: divega
ms.date: 10/23/2016
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
ms.openlocfilehash: 35b0284a5ad8b2b732f074589bd458d243312575
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/06/2020
ms.locfileid: "78419476"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="59811-102">Protokolování a zachycení databázových operací</span><span class="sxs-lookup"><span data-stu-id="59811-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="59811-103">**EF6 pouze** funkce, rozhraní API atd. popsané na této stránce byly představeny v Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="59811-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="59811-104">Pokud používáte starší verzi, některé nebo všechny tyto informace neplatí.</span><span class="sxs-lookup"><span data-stu-id="59811-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="59811-105">Počínaje Entity Framework 6, kdykoli Entity Framework odešle příkaz do databáze tento příkaz může zachytit kód aplikace.</span><span class="sxs-lookup"><span data-stu-id="59811-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="59811-106">Nejčastěji se používá pro protokolování SQL, ale dá se použít i k úpravě nebo přerušení příkazu.</span><span class="sxs-lookup"><span data-stu-id="59811-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="59811-107">Konkrétně EF zahrnuje:</span><span class="sxs-lookup"><span data-stu-id="59811-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="59811-108">Vlastnost protokolu pro kontext podobný kontextu DataContext. Přihlaste se LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="59811-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="59811-109">Mechanismus přizpůsobení obsahu a formátování výstupu odeslaného do protokolu</span><span class="sxs-lookup"><span data-stu-id="59811-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="59811-110">Stavební bloky nízké úrovně pro zachycení poskytující větší možnosti kontroly a flexibility</span><span class="sxs-lookup"><span data-stu-id="59811-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="59811-111">Vlastnost log kontextu</span><span class="sxs-lookup"><span data-stu-id="59811-111">Context Log property</span></span>  

<span data-ttu-id="59811-112">Vlastnost DbContext. Database. log lze nastavit na delegáta pro jakoukoliv metodu, která přebírá řetězec.</span><span class="sxs-lookup"><span data-stu-id="59811-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="59811-113">Nejčastěji se používá s jakýmkoli modulem TextWriter nastavením na metodu zápisu tohoto modulu TextWriter.</span><span class="sxs-lookup"><span data-stu-id="59811-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="59811-114">Všechny SQL generované aktuálním kontextem budou protokolovány do tohoto zapisovače.</span><span class="sxs-lookup"><span data-stu-id="59811-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="59811-115">Například následující kód bude protokolovat SQL do konzoly:</span><span class="sxs-lookup"><span data-stu-id="59811-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="59811-116">Všimněte si, že kontext. Database. log je nastavená na Console. Write.</span><span class="sxs-lookup"><span data-stu-id="59811-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="59811-117">To je všechno, co je potřeba k protokolování SQL do konzoly.</span><span class="sxs-lookup"><span data-stu-id="59811-117">This is all that is needed to log SQL to the console.</span></span>  

<span data-ttu-id="59811-118">Pojďme přidat nějaký jednoduchý kód pro dotaz, vložení/aktualizaci, aby se mohl zobrazit nějaký výstup:</span><span class="sxs-lookup"><span data-stu-id="59811-118">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="59811-119">Tím se vygeneruje následující výstup:</span><span class="sxs-lookup"><span data-stu-id="59811-119">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="59811-120">(Všimněte si, že se jedná o výstup za předpokladu, že nějaká inicializace databáze již proběhla.</span><span class="sxs-lookup"><span data-stu-id="59811-120">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="59811-121">Pokud inicializace databáze ještě neproběhla, měla by se zobrazit spousta dalších výstupů, na kterých se v rámci pokrývá všechny pracovní migrace za účelem kontroly nebo vytvoření nové databáze.)</span><span class="sxs-lookup"><span data-stu-id="59811-121">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

## <a name="what-gets-logged"></a><span data-ttu-id="59811-122">Co se protokoluje?</span><span class="sxs-lookup"><span data-stu-id="59811-122">What gets logged?</span></span>  

<span data-ttu-id="59811-123">Při nastavení vlastnosti log se zaprotokoluje následující:</span><span class="sxs-lookup"><span data-stu-id="59811-123">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="59811-124">SQL pro všechny různé druhy příkazů.</span><span class="sxs-lookup"><span data-stu-id="59811-124">SQL for all different kinds of commands.</span></span> <span data-ttu-id="59811-125">Příklad:</span><span class="sxs-lookup"><span data-stu-id="59811-125">For example:</span></span>  
    - <span data-ttu-id="59811-126">Dotazy, včetně normálních dotazů LINQ, dotazy eSQL a nezpracované dotazy z metod, jako je SqlQuery</span><span class="sxs-lookup"><span data-stu-id="59811-126">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="59811-127">Vložení, aktualizace a odstranění vygenerované jako součást metody SaveChanges</span><span class="sxs-lookup"><span data-stu-id="59811-127">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="59811-128">Vztah načítání dotazů, například generovaných opožděným načtením</span><span class="sxs-lookup"><span data-stu-id="59811-128">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="59811-129">Parametry</span><span class="sxs-lookup"><span data-stu-id="59811-129">Parameters</span></span>  
- <span data-ttu-id="59811-130">Bez ohledu na to, zda je příkaz prováděn asynchronně</span><span class="sxs-lookup"><span data-stu-id="59811-130">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="59811-131">Časové razítko, které signalizuje spuštění příkazu</span><span class="sxs-lookup"><span data-stu-id="59811-131">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="59811-132">Bez ohledu na to, jestli se příkaz úspěšně dokončil, selhala výjimka, nebo pro Async se zrušila operace.</span><span class="sxs-lookup"><span data-stu-id="59811-132">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="59811-133">Některé náznaky hodnoty výsledku</span><span class="sxs-lookup"><span data-stu-id="59811-133">Some indication of the result value</span></span>  
- <span data-ttu-id="59811-134">Přibližná doba, jakou trvalo spuštění příkazu.</span><span class="sxs-lookup"><span data-stu-id="59811-134">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="59811-135">Všimněte si, že se jedná o čas odeslání příkazu k získání objektu výsledku zpět.</span><span class="sxs-lookup"><span data-stu-id="59811-135">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="59811-136">Nezahrnuje čas pro čtení výsledků.</span><span class="sxs-lookup"><span data-stu-id="59811-136">It does not include time to read the results.</span></span>  

<span data-ttu-id="59811-137">Ve výše uvedeném příkladu se každý ze čtyř protokolovaných příkazů podívá:</span><span class="sxs-lookup"><span data-stu-id="59811-137">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="59811-138">Dotaz, který je výsledkem volání kontextu. Blogy. First</span><span class="sxs-lookup"><span data-stu-id="59811-138">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="59811-139">Všimněte si, že metoda ToString pro získání SQL by pro tento dotaz nefungovala, protože "First" neposkytuje rozhraní IQueryable, na které by mohlo být voláno rozhraní ToString.</span><span class="sxs-lookup"><span data-stu-id="59811-139">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="59811-140">Dotaz vyplývají z opožděného načítání blogu. Fórech</span><span class="sxs-lookup"><span data-stu-id="59811-140">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="59811-141">Všimněte si podrobností parametru pro hodnotu klíče, pro kterou probíhá opožděné načítání.</span><span class="sxs-lookup"><span data-stu-id="59811-141">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="59811-142">Protokolují se pouze vlastnosti parametru, které jsou nastaveny na jiné než výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="59811-142">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="59811-143">Například vlastnost Size se zobrazí pouze v případě, že je nenulová.</span><span class="sxs-lookup"><span data-stu-id="59811-143">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="59811-144">Dva příkazy, které jsou výsledkem SaveChangesAsync; jedna pro aktualizaci pro změnu názvu příspěvku, druhá pro vložení pro přidání nového příspěvku</span><span class="sxs-lookup"><span data-stu-id="59811-144">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="59811-145">Všimněte si podrobností parametru pro vlastnosti FK a title.</span><span class="sxs-lookup"><span data-stu-id="59811-145">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="59811-146">Všimněte si, že se tyto příkazy provádějí asynchronně.</span><span class="sxs-lookup"><span data-stu-id="59811-146">Notice that these commands are being executed asynchronously</span></span>  

## <a name="logging-to-different-places"></a><span data-ttu-id="59811-147">Protokolování na různá místa</span><span class="sxs-lookup"><span data-stu-id="59811-147">Logging to different places</span></span>  

<span data-ttu-id="59811-148">Jak vidíte výše, protokolování do konzoly je velice snadné.</span><span class="sxs-lookup"><span data-stu-id="59811-148">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="59811-149">Je také snadné protokolovat do paměti, souboru atd. pomocí různých druhů [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span><span class="sxs-lookup"><span data-stu-id="59811-149">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="59811-150">Pokud jste obeznámeni s LINQ to SQL, můžete si všimnout, že v části LINQ to SQL je vlastnost protokolu nastavena na skutečný objekt TextWriter (například Console. out), zatímco v EF je vlastnost log nastavena na metodu, která přijímá řetězec (například , Console. Write nebo Console. out. Write).</span><span class="sxs-lookup"><span data-stu-id="59811-150">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="59811-151">Důvodem je oddělit EF od TextWriter tím, že přijmete libovolného delegáta, který může fungovat jako jímka pro řetězce.</span><span class="sxs-lookup"><span data-stu-id="59811-151">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="59811-152">Představte si například, že už máte nějaké protokolovací rozhraní a definujete metodu protokolování, například:</span><span class="sxs-lookup"><span data-stu-id="59811-152">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="59811-153">To může být zapojování do vlastnosti protokolu EF takto:</span><span class="sxs-lookup"><span data-stu-id="59811-153">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

## <a name="result-logging"></a><span data-ttu-id="59811-154">Protokolování výsledků</span><span class="sxs-lookup"><span data-stu-id="59811-154">Result logging</span></span>  

<span data-ttu-id="59811-155">Výchozí protokolovací nástroj protokoluje text příkazu (SQL), parametry a "spouští" řádek s časovým razítkem před odesláním příkazu do databáze.</span><span class="sxs-lookup"><span data-stu-id="59811-155">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="59811-156">Po provedení příkazu se zaprotokoluje dokončený řádek obsahující uplynulý čas.</span><span class="sxs-lookup"><span data-stu-id="59811-156">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="59811-157">Všimněte si, že pro asynchronní příkazy se "dokončený" řádek nezaznamenává do chvíle, kdy je asynchronní úkol dokončen, dojde k chybě nebo byl zrušen.</span><span class="sxs-lookup"><span data-stu-id="59811-157">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="59811-158">Řádek dokončeno obsahuje různé informace v závislosti na typu příkazu a na tom, zda bylo spuštění úspěšné.</span><span class="sxs-lookup"><span data-stu-id="59811-158">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

### <a name="successful-execution"></a><span data-ttu-id="59811-159">Úspěšné provedení</span><span class="sxs-lookup"><span data-stu-id="59811-159">Successful execution</span></span>  

<span data-ttu-id="59811-160">Pro příkazy, které se úspěšně dokončily, se výstup dokončí v x MS s výsledkem: následovaný nějakým náznakem toho, co byl výsledek.</span><span class="sxs-lookup"><span data-stu-id="59811-160">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="59811-161">Pro příkazy, které vracejí data Reader, je výsledkem výsledná indikace typ vráceného typu [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) .</span><span class="sxs-lookup"><span data-stu-id="59811-161">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="59811-162">Pro příkazy, které vrátí celočíselnou hodnotu, jako je například příkaz Update zobrazený výše zobrazeným výsledkem, je toto celé číslo.</span><span class="sxs-lookup"><span data-stu-id="59811-162">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

### <a name="failed-execution"></a><span data-ttu-id="59811-163">Neúspěšné provedení</span><span class="sxs-lookup"><span data-stu-id="59811-163">Failed execution</span></span>  

<span data-ttu-id="59811-164">Pro příkazy, které selžou při vyvolání výjimky, výstup obsahuje zprávu z výjimky.</span><span class="sxs-lookup"><span data-stu-id="59811-164">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="59811-165">Například použití SqlQuery k dotazování na tabulku, která existuje, bude mít za následek výstup protokolu podobný tomuto:</span><span class="sxs-lookup"><span data-stu-id="59811-165">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

### <a name="canceled-execution"></a><span data-ttu-id="59811-166">Zrušené provedení</span><span class="sxs-lookup"><span data-stu-id="59811-166">Canceled execution</span></span>  

<span data-ttu-id="59811-167">V případě asynchronních příkazů, kde je úloha zrušena, může být výsledkem chyba s výjimkou, protože se jedná o to, co nadřízený poskytovatel ADO.NET často provádí při pokusu o zrušení.</span><span class="sxs-lookup"><span data-stu-id="59811-167">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="59811-168">Pokud k tomu nedojde a úloha se zruší čistě, bude výstup vypadat přibližně takto:</span><span class="sxs-lookup"><span data-stu-id="59811-168">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```console
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="59811-169">Změna obsahu a formátování protokolu</span><span class="sxs-lookup"><span data-stu-id="59811-169">Changing log content and formatting</span></span>  

<span data-ttu-id="59811-170">V části pokrývá vlastnost Database. log využívá objekt DatabaseLogFormatter.</span><span class="sxs-lookup"><span data-stu-id="59811-170">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="59811-171">Tento objekt efektivně váže implementaci IDbCommandInterceptor (viz níže) k delegátovi, který přijímá řetězce a DbContext.</span><span class="sxs-lookup"><span data-stu-id="59811-171">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="59811-172">To znamená, že metody v DatabaseLogFormatter jsou volány před a po provedení příkazů podle EF.</span><span class="sxs-lookup"><span data-stu-id="59811-172">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="59811-173">Tyto metody DatabaseLogFormatter shromažďují a formátují výstup protokolu a odesílají je do delegáta.</span><span class="sxs-lookup"><span data-stu-id="59811-173">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="59811-174">Přizpůsobení DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="59811-174">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="59811-175">Změna toho, co je protokolováno a jak je formátováno, lze dosáhnout vytvořením nové třídy, která je odvozena z DatabaseLogFormatter a potlačení metod podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="59811-175">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="59811-176">Nejběžnější metody přepsání:</span><span class="sxs-lookup"><span data-stu-id="59811-176">The most common methods to override are:</span></span>  

- <span data-ttu-id="59811-177">LogCommand – přepište tuto změnu, chcete-li změnit způsob, jakým jsou protokolovány příkazy před jejich spuštěním.</span><span class="sxs-lookup"><span data-stu-id="59811-177">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="59811-178">Ve výchozím nastavení LogCommand volá LogParameter pro každý parametr; místo toho se můžete rozhodnout v parametrech přepisu nebo pořizování jinak.</span><span class="sxs-lookup"><span data-stu-id="59811-178">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="59811-179">LogResult – přepište tuto změnu, chcete-li změnit způsob, jakým je výsledek spuštění příkazu zaznamenán.</span><span class="sxs-lookup"><span data-stu-id="59811-179">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="59811-180">LogParameter – toto přepište pro změnu formátování a obsahu protokolování parametrů.</span><span class="sxs-lookup"><span data-stu-id="59811-180">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="59811-181">Předpokládejme například, že jsme chtěli protokolovat pouze jeden řádek před odesláním každého příkazu do databáze.</span><span class="sxs-lookup"><span data-stu-id="59811-181">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="59811-182">Můžete to udělat se dvěma přepsáními:</span><span class="sxs-lookup"><span data-stu-id="59811-182">This can be done with two overrides:</span></span>  

- <span data-ttu-id="59811-183">Přepsat LogCommand pro formátování a zápis jednoho řádku SQL</span><span class="sxs-lookup"><span data-stu-id="59811-183">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="59811-184">Přepište LogResult, aby nedošlo k žádné akci.</span><span class="sxs-lookup"><span data-stu-id="59811-184">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="59811-185">Kód by vypadal přibližně takto:</span><span class="sxs-lookup"><span data-stu-id="59811-185">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="59811-186">Do log output stačí zavolat metodu zápisu, která odešle výstup do konfigurovaného delegáta pro zápis.</span><span class="sxs-lookup"><span data-stu-id="59811-186">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="59811-187">(Všimněte si, že tento kód provede odebrání konců řádků pouze jako příklad.</span><span class="sxs-lookup"><span data-stu-id="59811-187">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="59811-188">Nebude nejspíš fungovat dobře pro zobrazení složitého SQL.)</span><span class="sxs-lookup"><span data-stu-id="59811-188">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="59811-189">Nastavení DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="59811-189">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="59811-190">Po vytvoření nové třídy DatabaseLogFormatter musí být zaregistrována v EF.</span><span class="sxs-lookup"><span data-stu-id="59811-190">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="59811-191">To se provádí pomocí konfigurace založené na kódu.</span><span class="sxs-lookup"><span data-stu-id="59811-191">This is done using code-based configuration.</span></span> <span data-ttu-id="59811-192">V kostce to znamená vytvořit novou třídu, která je odvozena z DbConfiguration ve stejném sestavení jako vaše třída DbContext a pak volat SetDatabaseLogFormatter v konstruktoru této nové třídy.</span><span class="sxs-lookup"><span data-stu-id="59811-192">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="59811-193">Příklad:</span><span class="sxs-lookup"><span data-stu-id="59811-193">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="59811-194">Použití nového DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="59811-194">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="59811-195">Tento nový DatabaseLogFormatter se teď použije jako soubor Anytime Database. log.</span><span class="sxs-lookup"><span data-stu-id="59811-195">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="59811-196">Takže spuštění kódu z části 1 teď má za následek následující výstup:</span><span class="sxs-lookup"><span data-stu-id="59811-196">So, running the code from part 1 will now result in the following output:</span></span>  

```console
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="59811-197">Stavební bloky zachycení</span><span class="sxs-lookup"><span data-stu-id="59811-197">Interception building blocks</span></span>  

<span data-ttu-id="59811-198">Zatím jsme si vyhledali, jak používat DbContext. Database. log k protokolování SQL generovaných EF.</span><span class="sxs-lookup"><span data-stu-id="59811-198">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="59811-199">Tento kód je ale ve skutečnosti relativně tenká fasáda v některých stavebních blocích nízké úrovně pro obecnější zachycení.</span><span class="sxs-lookup"><span data-stu-id="59811-199">But this code is actually a relatively thin facade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="59811-200">Rozhraní zachycení</span><span class="sxs-lookup"><span data-stu-id="59811-200">Interception interfaces</span></span>  

<span data-ttu-id="59811-201">Kód zachycení je sestaven kolem konceptu rozhraní zachycení.</span><span class="sxs-lookup"><span data-stu-id="59811-201">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="59811-202">Tato rozhraní dědí z IDbInterceptor a definují metody, které jsou volány, když EF provede určitou akci.</span><span class="sxs-lookup"><span data-stu-id="59811-202">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="59811-203">Záměrem je, aby bylo možné zachytit jedno rozhraní na typ objektu.</span><span class="sxs-lookup"><span data-stu-id="59811-203">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="59811-204">Například rozhraní IDbCommandInterceptor definuje metody, které jsou volány před EF, provede volání ExecuteNonQuery, ExecuteScalar, ExecuteReader a souvisejících metod.</span><span class="sxs-lookup"><span data-stu-id="59811-204">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="59811-205">Podobně rozhraní definuje metody, které jsou volány při dokončení každé z těchto operací.</span><span class="sxs-lookup"><span data-stu-id="59811-205">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="59811-206">Třída DatabaseLogFormatter, kterou jsme prohlédli výše, implementuje toto rozhraní k protokolování příkazů.</span><span class="sxs-lookup"><span data-stu-id="59811-206">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="59811-207">Kontext zachycení</span><span class="sxs-lookup"><span data-stu-id="59811-207">The interception context</span></span>  

<span data-ttu-id="59811-208">V případě metod, které jsou definovány v jakémkoli rozhraní zachytávací, je zřejmé, že každé volání je předané objektu typu DbInterceptionContext nebo nějaký typ odvozený z tohoto typu, jako je například DbCommandInterceptionContext\<\>.</span><span class="sxs-lookup"><span data-stu-id="59811-208">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="59811-209">Tento objekt obsahuje kontextové informace o akci, kterou EF vezme.</span><span class="sxs-lookup"><span data-stu-id="59811-209">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="59811-210">Například pokud je akce prováděna jménem DbContext, pak DbContext je součástí DbInterceptionContext.</span><span class="sxs-lookup"><span data-stu-id="59811-210">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="59811-211">Podobně pro příkazy, které jsou spouštěny asynchronně, je příznak-Async nastaven na DbCommandInterceptionContext.</span><span class="sxs-lookup"><span data-stu-id="59811-211">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="59811-212">Zpracování výsledku</span><span class="sxs-lookup"><span data-stu-id="59811-212">Result handling</span></span>  

<span data-ttu-id="59811-213">Třída DbCommandInterceptionContext\<\> obsahuje vlastnosti nazvané výsledek, OriginalResult, výjimka a OriginalException.</span><span class="sxs-lookup"><span data-stu-id="59811-213">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="59811-214">Tyto vlastnosti jsou nastaveny na hodnotu null/nula pro volání metod zachycení, které jsou volány před spuštěním operace – to znamená pro... Spouštění metod.</span><span class="sxs-lookup"><span data-stu-id="59811-214">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="59811-215">Pokud je operace spuštěná a úspěšná, pak se výsledek a OriginalResult nastaví na výsledek operace.</span><span class="sxs-lookup"><span data-stu-id="59811-215">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="59811-216">Tyto hodnoty lze následně pozorovat v metodách zachycení, které jsou volány po provedení operace – to znamená na... Spouštěné metody.</span><span class="sxs-lookup"><span data-stu-id="59811-216">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="59811-217">Podobně platí, že pokud operace vyvolá, budou nastaveny vlastnosti Exception a OriginalException.</span><span class="sxs-lookup"><span data-stu-id="59811-217">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="59811-218">Potlačení provádění</span><span class="sxs-lookup"><span data-stu-id="59811-218">Suppressing execution</span></span>  

<span data-ttu-id="59811-219">Pokud zachytává Vlastnost Result před provedením příkazu (v jednom z těchto... Po spuštění metod) se EF nepokusí spustit příkaz, ale místo toho použije sadu výsledků.</span><span class="sxs-lookup"><span data-stu-id="59811-219">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="59811-220">Jinými slovy, zachytávací modul může potlačit provádění příkazu, ale měl by mít v kódu EF pokračovat, jako kdyby byl příkaz proveden.</span><span class="sxs-lookup"><span data-stu-id="59811-220">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="59811-221">Příkladem toho, jak to lze použít, je dávkování příkazů, které bylo tradičně provedeno s poskytovatelem zabalení.</span><span class="sxs-lookup"><span data-stu-id="59811-221">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="59811-222">Zachytávací příkaz by uložil příkaz pro pozdější spuštění jako dávku, ale měl by být "předstírat" na EF, že příkaz byl proveden jako normální.</span><span class="sxs-lookup"><span data-stu-id="59811-222">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="59811-223">Všimněte si, že k implementaci dávkového zpracování vyžaduje více než tento postup, ale jedná se například o způsob, jakým je možné použít změnu výsledku zachycení.</span><span class="sxs-lookup"><span data-stu-id="59811-223">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="59811-224">Spuštění lze také potlačit nastavením vlastnosti Exception v jednom z... Spouštění metod.</span><span class="sxs-lookup"><span data-stu-id="59811-224">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="59811-225">To způsobuje, že EF pokračuje jako v případě, že provedení operace selhalo vyvoláním dané výjimky.</span><span class="sxs-lookup"><span data-stu-id="59811-225">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="59811-226">To může samozřejmě způsobit chybu aplikace, ale může to být také přechodná výjimka nebo jiná výjimka, která je zpracována EF.</span><span class="sxs-lookup"><span data-stu-id="59811-226">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="59811-227">To může být například použito v testovacích prostředích k otestování chování aplikace při neúspěšném spuštění příkazu.</span><span class="sxs-lookup"><span data-stu-id="59811-227">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="59811-228">Změna výsledku po spuštění</span><span class="sxs-lookup"><span data-stu-id="59811-228">Changing the result after execution</span></span>  

<span data-ttu-id="59811-229">Pokud zachytávací Vlastnost Result nastaví po provedení příkazu (v jedné z vlastností... Spouštěné metody), pak EF použije změněný výsledek místo výsledku, který byl skutečně vrácen z operace.</span><span class="sxs-lookup"><span data-stu-id="59811-229">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="59811-230">Podobně, pokud zachytává událost nastaví vlastnost Exception po provedení příkazu, pak EF vyvolá výjimku set, jako kdyby byla výjimka vyvolána v operaci.</span><span class="sxs-lookup"><span data-stu-id="59811-230">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="59811-231">Zachytávací objekt může také nastavit vlastnost Exception na hodnotu null, aby označovala, že by neměla být vyvolána žádná výjimka.</span><span class="sxs-lookup"><span data-stu-id="59811-231">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="59811-232">To může být užitečné v případě, že provedení operace se nezdařilo, ale zachytávací, který chce EF pokračovat, jako kdyby operace proběhla úspěšně.</span><span class="sxs-lookup"><span data-stu-id="59811-232">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="59811-233">To obvykle zahrnuje nastavení výsledku tak, aby měl EF při pokračování nějakou hodnotu výsledku.</span><span class="sxs-lookup"><span data-stu-id="59811-233">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="59811-234">OriginalResult a OriginalException</span><span class="sxs-lookup"><span data-stu-id="59811-234">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="59811-235">Po provedení operace v EF se nastaví buď vlastnosti Result a OriginalResult, pokud spuštění neselže, nebo pokud se spuštění nezdařilo, došlo k chybě s výjimkou.</span><span class="sxs-lookup"><span data-stu-id="59811-235">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="59811-236">Vlastnosti OriginalResult a OriginalException jsou jen pro čtení a nastavují je jenom EF v rámci skutečného provedení operace.</span><span class="sxs-lookup"><span data-stu-id="59811-236">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="59811-237">Tyto vlastnosti nelze nastavit pomocí zachycení.</span><span class="sxs-lookup"><span data-stu-id="59811-237">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="59811-238">To znamená, že jakýkoliv zachytávací může rozlišovat výjimku nebo výsledek, který byl nastaven jiným zachytávací, na rozdíl od reálné výjimky nebo výsledek, ke kterému došlo při provedení operace.</span><span class="sxs-lookup"><span data-stu-id="59811-238">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="59811-239">Registrace zachycení</span><span class="sxs-lookup"><span data-stu-id="59811-239">Registering interceptors</span></span>  

<span data-ttu-id="59811-240">Jakmile je třída, která implementuje jedno nebo více rozhraní zachycení, vytvořena, může být zaregistrována s EF pomocí třídy DbInterception.</span><span class="sxs-lookup"><span data-stu-id="59811-240">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="59811-241">Příklad:</span><span class="sxs-lookup"><span data-stu-id="59811-241">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="59811-242">Zachycení lze také registrovat na úrovni aplikačních domén pomocí mechanismu konfigurace založeného na kódu DbConfiguration.</span><span class="sxs-lookup"><span data-stu-id="59811-242">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="59811-243">Příklad: protokolování do NLog</span><span class="sxs-lookup"><span data-stu-id="59811-243">Example: Logging to NLog</span></span>  

<span data-ttu-id="59811-244">Pojďme to všechno dohromady do příkladu, který používá IDbCommandInterceptor a [nLOG](https://nlog-project.org/) k:</span><span class="sxs-lookup"><span data-stu-id="59811-244">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](https://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="59811-245">Zaprotokoluje upozornění pro všechny příkazy, které se provedly bez asynchronního zpracování.</span><span class="sxs-lookup"><span data-stu-id="59811-245">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="59811-246">Zaznamená chybu pro jakýkoli příkaz, který vyvolá při spuštění.</span><span class="sxs-lookup"><span data-stu-id="59811-246">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="59811-247">Zde je třída, která provede protokolování, které by mělo být registrováno, jak je uvedeno výše:</span><span class="sxs-lookup"><span data-stu-id="59811-247">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="59811-248">Všimněte si, jak tento kód používá kontext zachycení ke zjištění, že se příkaz provádí neasynchronně a že při provádění příkazu se zjistila chyba.</span><span class="sxs-lookup"><span data-stu-id="59811-248">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
