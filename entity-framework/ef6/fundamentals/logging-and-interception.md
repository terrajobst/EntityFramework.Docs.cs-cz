---
title: Protokolování a zachycení databázových operací - EF6
author: divega
ms.date: 2016-10-23
ms.prod: entity-framework
ms.author: divega
ms.manager: avickers
ms.technology: entity-framework-6
ms.topic: article
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
caps.latest.revision: 3
ms.openlocfilehash: 9c95b7490c11a28524a1468518261aa4bc317262
ms.sourcegitcommit: 390f3a37bc55105ed7cc5b0e0925b7f9c9e80ba6
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/09/2018
ms.locfileid: "37914269"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="74069-102">Protokolování a zachycení databázové operace</span><span class="sxs-lookup"><span data-stu-id="74069-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="74069-103">**EF6 a vyšší pouze** – funkce rozhraní API, atd. popsané na této stránce se zavedly v Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="74069-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="74069-104">Pokud používáte starší verzi, některé nebo všechny informace neplatí.</span><span class="sxs-lookup"><span data-stu-id="74069-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="74069-105">Od verze Entity Framework 6, kdykoliv Entity Framework odešle příkaz do databáze tohoto příkazu může být zachycen kódu aplikace.</span><span class="sxs-lookup"><span data-stu-id="74069-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="74069-106">To se většinou používá při protokolování SQL, ale můžete také použít ke změně nebo zrušení příkazu.</span><span class="sxs-lookup"><span data-stu-id="74069-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="74069-107">Konkrétně EF zahrnuje:</span><span class="sxs-lookup"><span data-stu-id="74069-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="74069-108">Vlastnosti protokolu pro daný kontext podobný DataContext.Log v technologii LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="74069-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="74069-109">Mechanismus pro přizpůsobení obsahu a formátování výstupu odesílány do protokolu</span><span class="sxs-lookup"><span data-stu-id="74069-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="74069-110">Nízké úrovně stavební bloky pro zachycení poskytuje větší ovládací prvek/flexibilitu</span><span class="sxs-lookup"><span data-stu-id="74069-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="74069-111">Vlastnost Context protokolu</span><span class="sxs-lookup"><span data-stu-id="74069-111">Context Log property</span></span>  

<span data-ttu-id="74069-112">Vlastnost DbContext.Database.Log můžete nastavit na delegáta pro libovolnou metodu, která přebírá řetězec.</span><span class="sxs-lookup"><span data-stu-id="74069-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="74069-113">Nejčastěji se používá s jakékoli TextWriter nastavením na metody "Zápisu" Tento TextWriter.</span><span class="sxs-lookup"><span data-stu-id="74069-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="74069-114">Všechny SQL generovaných aktuálním kontextu se budou protokolovat do tohoto zapisovače.</span><span class="sxs-lookup"><span data-stu-id="74069-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="74069-115">Například následující kód se budou protokolovat SQL do konzoly:</span><span class="sxs-lookup"><span data-stu-id="74069-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="74069-116">Všimněte si, že tento kontext. Database.Log nastavená na Console.Write.</span><span class="sxs-lookup"><span data-stu-id="74069-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="74069-117">To je vše, co je potřeba pro SQL přihlášení ke konzole.</span><span class="sxs-lookup"><span data-stu-id="74069-117">This is all that is needed to log SQL to the console.</span></span>  

### <a name="example-output"></a><span data-ttu-id="74069-118">Příklad výstupu</span><span class="sxs-lookup"><span data-stu-id="74069-118">Example output</span></span>  

<span data-ttu-id="74069-119">Přidejme jednoduchého kódu query/insert nebo update, jsme viděli některé výstup:</span><span class="sxs-lookup"><span data-stu-id="74069-119">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="74069-120">Tím se vygeneruje následující výstup:</span><span class="sxs-lookup"><span data-stu-id="74069-120">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="74069-121">(Všimněte si, že se jedná o výstup, za předpokladu, že již došlo k inicializaci žádné databáze.</span><span class="sxs-lookup"><span data-stu-id="74069-121">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="74069-122">Pokud inicializaci databáze nebyly již došlo k pak bude mnohem více výstup zobrazuje všechnu práci migrace provede na pozadí vyhledat nebo vytvořit novou databázi.)</span><span class="sxs-lookup"><span data-stu-id="74069-122">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

### <a name="what-gets-logged"></a><span data-ttu-id="74069-123">Co získá přihlášení?</span><span class="sxs-lookup"><span data-stu-id="74069-123">What gets logged?</span></span>  

<span data-ttu-id="74069-124">Když je vlastnost protokolu nastavena všechny tyto se protokolovat:</span><span class="sxs-lookup"><span data-stu-id="74069-124">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="74069-125">SQL pro všechny různé druhy příkazy.</span><span class="sxs-lookup"><span data-stu-id="74069-125">SQL for all different kinds of commands.</span></span> <span data-ttu-id="74069-126">Příklad:</span><span class="sxs-lookup"><span data-stu-id="74069-126">For example:</span></span>  
    - <span data-ttu-id="74069-127">Dotazy, včetně běžných dotazů LINQ, eSQL dotazy a nezpracované dotazy z metod, jako je například SqlQuery</span><span class="sxs-lookup"><span data-stu-id="74069-127">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="74069-128">Vložení, aktualizace a odstranění generována jako součást SaveChanges</span><span class="sxs-lookup"><span data-stu-id="74069-128">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="74069-129">Relace načítání dotazů, jako jsou protokoly generované systémem opožděné načtení</span><span class="sxs-lookup"><span data-stu-id="74069-129">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="74069-130">Parametry</span><span class="sxs-lookup"><span data-stu-id="74069-130">Parameters</span></span>  
- <span data-ttu-id="74069-131">Určuje, jestli tento příkaz se provádí asynchronně</span><span class="sxs-lookup"><span data-stu-id="74069-131">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="74069-132">Časové razítko určující, kdy příkaz zahájilo se spuštění</span><span class="sxs-lookup"><span data-stu-id="74069-132">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="74069-133">Jestli se nedokončil úspěšně, příkaz se nezdařil, vyvoláním výjimky nebo pro asynchronní, byla zrušena.</span><span class="sxs-lookup"><span data-stu-id="74069-133">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="74069-134">Některá označení výsledná hodnota</span><span class="sxs-lookup"><span data-stu-id="74069-134">Some indication of the result value</span></span>  
- <span data-ttu-id="74069-135">Přibližná množství času, které trvalo provedení příkazu.</span><span class="sxs-lookup"><span data-stu-id="74069-135">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="74069-136">Všimněte si, že se jedná o času v odesílání příkazu k získání objektu výsledek zpět.</span><span class="sxs-lookup"><span data-stu-id="74069-136">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="74069-137">Doba čtení výsledků neobsahuje.</span><span class="sxs-lookup"><span data-stu-id="74069-137">It does not include time to read the results.</span></span>  

<span data-ttu-id="74069-138">Hledání na výše uvedeném příkladu výstupu, každý ze čtyř příkazů protokoluje jsou:</span><span class="sxs-lookup"><span data-stu-id="74069-138">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="74069-139">Dotaz vyplývající z volání kontextu. Blogs.First</span><span class="sxs-lookup"><span data-stu-id="74069-139">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="74069-140">Všimněte si, že Metoda ToString získání SQL nebude mít pracoval pro tento dotaz od "First" neposkytuje položku IQueryable, na kterém se mohl nazývat ToString</span><span class="sxs-lookup"><span data-stu-id="74069-140">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="74069-141">Dotaz vyplývající z blogu opožděné načtení. Příspěvky</span><span class="sxs-lookup"><span data-stu-id="74069-141">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="74069-142">Všimněte si, že se děje podrobnosti parametr pro hodnotu klíče, pro které opožděné načtení</span><span class="sxs-lookup"><span data-stu-id="74069-142">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="74069-143">Pouze vlastnosti parametru, které jsou nastaveny na jiné než výchozí hodnoty jsou protokolovány.</span><span class="sxs-lookup"><span data-stu-id="74069-143">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="74069-144">Například vlastnost velikosti se zobrazí pouze pokud je nulová.</span><span class="sxs-lookup"><span data-stu-id="74069-144">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="74069-145">Dva příkazy vyplývající z SaveChangesAsync; jeden pro aktualizace, chcete-li změnit název post, druhá pro vložení pro přidání nového příspěvku</span><span class="sxs-lookup"><span data-stu-id="74069-145">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="74069-146">Všimněte si, že parametr podrobné vlastnosti cizího klíče a funkce</span><span class="sxs-lookup"><span data-stu-id="74069-146">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="74069-147">Všimněte si, že tyto příkazy se spouštějí asynchronně</span><span class="sxs-lookup"><span data-stu-id="74069-147">Notice that these commands are being executed asynchronously</span></span>  

### <a name="logging-to-different-places"></a><span data-ttu-id="74069-148">Protokolování na různých místech</span><span class="sxs-lookup"><span data-stu-id="74069-148">Logging to different places</span></span>  

<span data-ttu-id="74069-149">Jak je znázorněno výše protokolování do konzoly máte velmi snadný.</span><span class="sxs-lookup"><span data-stu-id="74069-149">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="74069-150">Se dá taky snadno protokolovat do paměti, souborů, atd. pomocí různých typů z [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span><span class="sxs-lookup"><span data-stu-id="74069-150">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="74069-151">Pokud jste se seznámili s jazykem LINQ to SQL můžete všimnout, že v technologii LINQ to SQL protokolu je nastavena na skutečné TextWriter objektu (například Console.Out) při v EF protokolu vlastnost nastavena na metodu, která přijímá řetězec (např. Console.Write nebo Console.Out.Write).</span><span class="sxs-lookup"><span data-stu-id="74069-151">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (e.g. Console.Out) while in EF the Log property is set to a method that accepts a string (e.g. Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="74069-152">Důvodem je oddělit EF z TextWriter přijetím jakýkoli delegát, který může fungovat jako jímka pro řetězce.</span><span class="sxs-lookup"><span data-stu-id="74069-152">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="74069-153">Představte si například, že už máte některé protokolovacího rozhraní a definuje metodu protokolování takto:</span><span class="sxs-lookup"><span data-stu-id="74069-153">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="74069-154">To může být připojili k vlastnosti EF protokolu následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="74069-154">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

### <a name="result-logging"></a><span data-ttu-id="74069-155">Výsledek protokolování</span><span class="sxs-lookup"><span data-stu-id="74069-155">Result logging</span></span>  

<span data-ttu-id="74069-156">Protokolovací nástroj výchozí text příkazu (SQL), parametry a protokoly "Zpracování" řádku s časovým razítkem před odesláním příkazu do databáze.</span><span class="sxs-lookup"><span data-stu-id="74069-156">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="74069-157">"Dokončených" řádek obsahující uplynulý čas je zaznamenané následující provedení příkazu.</span><span class="sxs-lookup"><span data-stu-id="74069-157">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="74069-158">Všimněte si, že pro asynchronní příkazy "dokončených" řádku není přihlášen, dokud se asynchronní úlohy ve skutečnosti se dokončí, selže nebo je zrušena.</span><span class="sxs-lookup"><span data-stu-id="74069-158">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="74069-159">"Dokončených" řádek obsahuje různé informace v závislosti na typu příkazu a určuje, jestli spuštění proběhlo úspěšně.</span><span class="sxs-lookup"><span data-stu-id="74069-159">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

#### <a name="successful-execution"></a><span data-ttu-id="74069-160">Úspěšná spuštění</span><span class="sxs-lookup"><span data-stu-id="74069-160">Successful execution</span></span>  

<span data-ttu-id="74069-161">Příkazy, které úspěšně dokončit výstup je "dokončeno v x ms s výsledkem:" následované některé indikace toho, co bylo výsledek.</span><span class="sxs-lookup"><span data-stu-id="74069-161">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="74069-162">Pro příkazy, které vracejí výsledek čtecí modul dat je označení typu [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) vrátila.</span><span class="sxs-lookup"><span data-stu-id="74069-162">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="74069-163">Pro příkazy, které vrátí celočíselnou hodnotu, jako je například aktualizace je uvedenému výše ukazuje výsledek tohoto celé číslo.</span><span class="sxs-lookup"><span data-stu-id="74069-163">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

#### <a name="failed-execution"></a><span data-ttu-id="74069-164">Neúspěšné provedení</span><span class="sxs-lookup"><span data-stu-id="74069-164">Failed execution</span></span>  

<span data-ttu-id="74069-165">Výstup obsahuje příkazy, které selhání vyvoláním výjimky, zprávu výjimky.</span><span class="sxs-lookup"><span data-stu-id="74069-165">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="74069-166">Například pomocí dotazu na tabulku, která neexistuje SqlQuery se v protokolu výstupu výsledků vypadat přibližně takto:</span><span class="sxs-lookup"><span data-stu-id="74069-166">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

#### <a name="canceled-execution"></a><span data-ttu-id="74069-167">Zrušená spuštění</span><span class="sxs-lookup"><span data-stu-id="74069-167">Canceled execution</span></span>  

<span data-ttu-id="74069-168">Pro asynchronní příkazy, kde je tato úloha nezruší výsledek může být chyba s výjimkou, protože se jedná podkladového zprostředkovatele ADO.NET často význam při pokusu o zrušení.</span><span class="sxs-lookup"><span data-stu-id="74069-168">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="74069-169">Pokud rovnosti a úloha se zruší čistě pak výstup bude vypadat přibližně takto:</span><span class="sxs-lookup"><span data-stu-id="74069-169">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```  
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="74069-170">Změna obsah protokolu a formátování</span><span class="sxs-lookup"><span data-stu-id="74069-170">Changing log content and formatting</span></span>  

### <a name="databaselogformatter"></a><span data-ttu-id="74069-171">DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="74069-171">DatabaseLogFormatter</span></span>  

<span data-ttu-id="74069-172">Pod pokličkou Database.Log vlastnost díky využívání DatabaseLogFormatter objektu.</span><span class="sxs-lookup"><span data-stu-id="74069-172">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="74069-173">Tento objekt efektivně váže IDbCommandInterceptor implementaci (viz níže) na delegáta, který přijímá řetězce a DbContext.</span><span class="sxs-lookup"><span data-stu-id="74069-173">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="74069-174">To znamená, že v DatabaseLogFormatter metody jsou volány před a po spuštění příkazů EF.</span><span class="sxs-lookup"><span data-stu-id="74069-174">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="74069-175">Tyto metody DatabaseLogFormatter shromažďovat a formátování výstupu protokolu a odeslat do delegáta.</span><span class="sxs-lookup"><span data-stu-id="74069-175">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="74069-176">Přizpůsobení DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="74069-176">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="74069-177">Změna co a jak je formátovaný můžete dosáhnout tím, že vytvoříte novou třídu, která je odvozena z DatabaseLogFormatter a přepíše metody podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="74069-177">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="74069-178">Nejběžnější metody přepsání jsou následující:</span><span class="sxs-lookup"><span data-stu-id="74069-178">The most common methods to override are:</span></span>  

- <span data-ttu-id="74069-179">LogCommand – změnit, změnit, jak jsou protokolovány příkazy předtím, než se spustí.</span><span class="sxs-lookup"><span data-stu-id="74069-179">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="74069-180">Ve výchozím nastavení LogCommand volá LogParameter pro každý parametr; můžete provést totéž v přepsání nebo zpracování parametrů jinak místo.</span><span class="sxs-lookup"><span data-stu-id="74069-180">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="74069-181">LogResult – změnit, změnit, jak se do protokolu zapíše výsledek spuštění příkazu.</span><span class="sxs-lookup"><span data-stu-id="74069-181">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="74069-182">LogParameter – změnit, změňte parametr protokolování obsahu a formátování.</span><span class="sxs-lookup"><span data-stu-id="74069-182">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="74069-183">Předpokládejme například, že jsme chtěli přihlásit jen jeden řádek před odesláním každý příkaz v databázi.</span><span class="sxs-lookup"><span data-stu-id="74069-183">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="74069-184">To můžete udělat s dva přepisy:</span><span class="sxs-lookup"><span data-stu-id="74069-184">This can be done with two overrides:</span></span>  

- <span data-ttu-id="74069-185">Přepsat LogCommand formátování a napsat jediný řádek SQL</span><span class="sxs-lookup"><span data-stu-id="74069-185">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="74069-186">Přepište LogResult neprovede žádnou akci.</span><span class="sxs-lookup"><span data-stu-id="74069-186">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="74069-187">Kód by vypadat přibližně takto:</span><span class="sxs-lookup"><span data-stu-id="74069-187">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="74069-188">Protokolovat výstup jednoduše volání zápisu metodu, která bude odesílat výstup delegáta nakonfigurované zápisu.</span><span class="sxs-lookup"><span data-stu-id="74069-188">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="74069-189">(Všimněte si, že tento kód provede zjednodušenou odebrání konců jenom jako příklad.</span><span class="sxs-lookup"><span data-stu-id="74069-189">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="74069-190">Nebude pravděpodobně fungovat dobře pro zobrazení komplexní SQL.)</span><span class="sxs-lookup"><span data-stu-id="74069-190">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="74069-191">Nastavení DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="74069-191">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="74069-192">Po jeho vytvoření nové třídy DatabaseLogFormatter musí být registrována pomocí EF.</span><span class="sxs-lookup"><span data-stu-id="74069-192">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="74069-193">To se provádí pomocí konfigurace založená na kódu.</span><span class="sxs-lookup"><span data-stu-id="74069-193">This is done using code-based configuration.</span></span> <span data-ttu-id="74069-194">Řečeno v kostce to znamená, že vytváří novou třídu, která je odvozena z DbConfiguration ve stejném sestavení jako vaší třídy DbContext a následným voláním SetDatabaseLogFormatter v konstruktoru tato nová třída.</span><span class="sxs-lookup"><span data-stu-id="74069-194">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="74069-195">Příklad:</span><span class="sxs-lookup"><span data-stu-id="74069-195">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="74069-196">Pomocí nové DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="74069-196">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="74069-197">Tento nový DatabaseLogFormatter budou se teď dá kdykoliv Database.Log nastavena.</span><span class="sxs-lookup"><span data-stu-id="74069-197">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="74069-198">Ano spouštění kódu z část 1 nyní způsobí následující výstup:</span><span class="sxs-lookup"><span data-stu-id="74069-198">So, running the code from part 1 will now result in the following output:</span></span>  

```  
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="74069-199">Stavební bloky zachycení</span><span class="sxs-lookup"><span data-stu-id="74069-199">Interception building blocks</span></span>  

<span data-ttu-id="74069-200">Zatím jsme se podívat na použití k protokolování SQL generovaných EF DbContext.Database.Log.</span><span class="sxs-lookup"><span data-stu-id="74069-200">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="74069-201">Ale tento kód je ve skutečnosti poměrně dynamického zajišťování průčelí přes některé nízké úrovně stavební bloky pro obecnější zachycení.</span><span class="sxs-lookup"><span data-stu-id="74069-201">But this code is actually a relatively thin façade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="74069-202">Zachycení rozhraní</span><span class="sxs-lookup"><span data-stu-id="74069-202">Interception interfaces</span></span>  

<span data-ttu-id="74069-203">Zachycení kódu byla vybudována okolo koncept zachycení rozhraní.</span><span class="sxs-lookup"><span data-stu-id="74069-203">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="74069-204">Tato rozhraní se dědí z IDbInterceptor a definovat metody, které jsou volány při EF provede určitou akci.</span><span class="sxs-lookup"><span data-stu-id="74069-204">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="74069-205">Cílem je mít jedno rozhraní na typ objektu, které jsou zachyceny.</span><span class="sxs-lookup"><span data-stu-id="74069-205">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="74069-206">Například IDbCommandInterceptor rozhraní definuje metody, které jsou volány před EF zavolá metodu ExecuteNonQuery, ExecuteScalar, ExecuteReader a s ní související metody.</span><span class="sxs-lookup"><span data-stu-id="74069-206">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="74069-207">Obdobně rozhraní definuje metody, které jsou volány při dokončení každé z těchto operací.</span><span class="sxs-lookup"><span data-stu-id="74069-207">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="74069-208">DatabaseLogFormatter třídu, která jsme se podívali na výše implementuje toto rozhraní k protokolování příkazy.</span><span class="sxs-lookup"><span data-stu-id="74069-208">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="74069-209">Zachycení kontextu</span><span class="sxs-lookup"><span data-stu-id="74069-209">The interception context</span></span>  

<span data-ttu-id="74069-210">Hledání na metody definované na žádném z rozhraní zachycování je zřejmé, že všechna volání je daný objekt typu DbInterceptionContext nebo typ odvozený od to například DbCommandInterceptionContext\<\>.</span><span class="sxs-lookup"><span data-stu-id="74069-210">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="74069-211">Tento objekt obsahuje kontextové informace o akci, která EF trvá.</span><span class="sxs-lookup"><span data-stu-id="74069-211">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="74069-212">Například pokud se právě používá akce jménem DbContext, pak uvolněn objekt DbContext je součástí DbInterceptionContext.</span><span class="sxs-lookup"><span data-stu-id="74069-212">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="74069-213">Podobně pro příkazy, které se spouštějí asynchronně, isasync: příznak nastaven na DbCommandInterceptionContext.</span><span class="sxs-lookup"><span data-stu-id="74069-213">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="74069-214">Výsledek zpracování</span><span class="sxs-lookup"><span data-stu-id="74069-214">Result handling</span></span>  

<span data-ttu-id="74069-215">DbCommandInterceptionContext\< \> třída obsahuje vlastnosti s názvem výsledek, OriginalResult, výjimky a původní výjimka.</span><span class="sxs-lookup"><span data-stu-id="74069-215">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="74069-216">Tyto vlastnosti jsou nastaveny na hodnotu null nebo nulu pro volání metody zachycení, které jsou volány, než se operace executed—i.e.... Provádění metody.</span><span class="sxs-lookup"><span data-stu-id="74069-216">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed—i.e. the …Executing methods.</span></span> <span data-ttu-id="74069-217">Pokud operace se spustí a proběhne úspěšně, potom výsledek a OriginalResult jsou nastavenou na výsledek operace.</span><span class="sxs-lookup"><span data-stu-id="74069-217">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="74069-218">Tyto hodnoty pak můžete pozorovat zachycení metody, které jsou volány po operaci má executed—i.e.... Provedený metody.</span><span class="sxs-lookup"><span data-stu-id="74069-218">These values can then be observed in the interception methods that are called after the operation has executed—i.e. the …Executed methods.</span></span> <span data-ttu-id="74069-219">Podobně pokud vyvolá operaci, pak výjimku a původní výjimka budou nastaveny vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="74069-219">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="74069-220">Potlačení spuštění</span><span class="sxs-lookup"><span data-stu-id="74069-220">Suppressing execution</span></span>  

<span data-ttu-id="74069-221">Pokud zachycování předtím, než se spustí příkaz nastaví vlastnost výsledek (v jednom z... Provádění metody) pak EF nepokusí se provést příkaz ve skutečnosti, ale budou místo toho použijte sadu výsledků dotazu.</span><span class="sxs-lookup"><span data-stu-id="74069-221">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="74069-222">Jinými slovy lze sběrač potlačit provedení příkazu ale mít EF pokračovat jako příkazu se provedl.</span><span class="sxs-lookup"><span data-stu-id="74069-222">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="74069-223">Příkaz dávkové zpracování, která proběhla tradičně s zabalení poskytovatele je příklad, jak to může být používána.</span><span class="sxs-lookup"><span data-stu-id="74069-223">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="74069-224">Sběrač by uložit pro pozdější provedení příkazu v dávce, ale by "předstírají, že" EF, který provedl příkazu jako za normálních okolností.</span><span class="sxs-lookup"><span data-stu-id="74069-224">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="74069-225">Všimněte si, že vyžaduje více než toto implementovat dávkové zpracování, ale toto je příklad použití Změna výsledku zachycení může být.</span><span class="sxs-lookup"><span data-stu-id="74069-225">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="74069-226">Spuštění lze potlačit také tak, že nastavíte vlastnost výjimky v jednom z... Provádění metody.</span><span class="sxs-lookup"><span data-stu-id="74069-226">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="74069-227">To způsobí, že EF pokračovat jako v případě provádění operace se nezdařila vyvoláním výjimka.</span><span class="sxs-lookup"><span data-stu-id="74069-227">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="74069-228">Samozřejmě to může způsobit aplikace ohlašování chyb, ale mohou být také s přechodnou výjimkou nebo jinou výjimku, kterou provádí služba EF.</span><span class="sxs-lookup"><span data-stu-id="74069-228">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="74069-229">Například to může použít v testovacích prostředích k testování chování aplikace při spuštění příkazu se nezdaří.</span><span class="sxs-lookup"><span data-stu-id="74069-229">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="74069-230">Změna výsledku po spuštění</span><span class="sxs-lookup"><span data-stu-id="74069-230">Changing the result after execution</span></span>  

<span data-ttu-id="74069-231">Pokud zachycování nastaví vlastnost výsledek po provedení příkazu (v jednom z... Spuštění metody) pak EF bude používat změněný výsledek místo výsledku, který se ve skutečnosti vrácená z operace.</span><span class="sxs-lookup"><span data-stu-id="74069-231">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="74069-232">Podobně pokud se zachycování nastaví vlastnost výjimky po provedení příkazu, pak EF vyvolá výjimku sady jako by operace měla vyvolána výjimka.</span><span class="sxs-lookup"><span data-stu-id="74069-232">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="74069-233">Zachycování můžete také nastavit vlastnost výjimku null k označení, že by měl být vyvolána žádná výjimka.</span><span class="sxs-lookup"><span data-stu-id="74069-233">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="74069-234">To může být užitečné, pokud se nepodařilo spustit operaci, ale sběrač si přeje EF, abyste mohli pokračovat, jako by se operace dokončila.</span><span class="sxs-lookup"><span data-stu-id="74069-234">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="74069-235">Obvykle to také zahrnuje nastavení výsledku tak, aby EF má některá z hodnot výsledek pro práci s jako pokračuje.</span><span class="sxs-lookup"><span data-stu-id="74069-235">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="74069-236">OriginalResult a původní výjimka</span><span class="sxs-lookup"><span data-stu-id="74069-236">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="74069-237">Po EF po provedení operace nastaví vlastnosti výsledek a OriginalResult, pokud byla úspěšná spuštění nebo vlastnosti výjimky a původní výjimka Pokud spuštění selhalo s výjimkou.</span><span class="sxs-lookup"><span data-stu-id="74069-237">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="74069-238">OriginalResult a původní výjimka vlastnosti jsou jen pro čtení a jsou nastaveny jenom pomocí EF po skutečně provedení operace.</span><span class="sxs-lookup"><span data-stu-id="74069-238">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="74069-239">Tyto vlastnosti nejde nastavit zachycovacích dotazů.</span><span class="sxs-lookup"><span data-stu-id="74069-239">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="74069-240">To znamená, že všechny zachycování možné rozlišit výjimku nebo výsledek, který je nastavená podle jiných zachycování na rozdíl od skutečné výjimky nebo výsledek, ke které došlo při operaci spustil.</span><span class="sxs-lookup"><span data-stu-id="74069-240">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="74069-241">Registrace zachycovacích dotazů</span><span class="sxs-lookup"><span data-stu-id="74069-241">Registering interceptors</span></span>  

<span data-ttu-id="74069-242">Po vytvoření třídy, která implementuje jednu nebo více rozhraní zachycení lze registrovat pomocí EF horizontálních oddílů pomocí třídy DbInterception.</span><span class="sxs-lookup"><span data-stu-id="74069-242">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="74069-243">Příklad:</span><span class="sxs-lookup"><span data-stu-id="74069-243">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="74069-244">Sběrače lze také zaregistrovat na úrovni domény aplikace pomocí mechanismu DbConfiguration konfigurace založená na kódu.</span><span class="sxs-lookup"><span data-stu-id="74069-244">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="74069-245">Příklad: Protokolování NLog</span><span class="sxs-lookup"><span data-stu-id="74069-245">Example: Logging to NLog</span></span>  

<span data-ttu-id="74069-246">Pojďme dohromady to vše na příklad, že při použití IDbCommandInterceptor a [NLog](http://nlog-project.org/) na:</span><span class="sxs-lookup"><span data-stu-id="74069-246">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](http://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="74069-247">Upozornění pro jakýkoli příkaz, který je spuštěn mimo asynchronně</span><span class="sxs-lookup"><span data-stu-id="74069-247">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="74069-248">Zaznamenat chybu pro jakýkoli příkaz, který vyvolá při spuštění</span><span class="sxs-lookup"><span data-stu-id="74069-248">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="74069-249">Tady je třída, která provádí protokolování, které by měly být zaregistrovány, jak je uvedeno výše:</span><span class="sxs-lookup"><span data-stu-id="74069-249">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="74069-250">Všimněte si, jak tento kód používá kontext zachycení ke zjištění, kdy příkaz se zpracovává jiné asynchronní a chcete zjistit, když došlo k chybě při spuštění příkazu.</span><span class="sxs-lookup"><span data-stu-id="74069-250">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
