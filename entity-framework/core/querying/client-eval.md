---
title: Vyhodnocení klienta vs. serveru – ef jádro
author: smitpatel
ms.date: 10/03/2019
ms.assetid: 8b6697cc-7067-4dc2-8007-85d80503d123
uid: core/querying/client-eval
ms.openlocfilehash: e01bd146c4dfe7a8d36b641cb52ae366fddd8239
ms.sourcegitcommit: 9b562663679854c37c05fca13d93e180213fb4aa
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/07/2020
ms.locfileid: "78417758"
---
# <a name="client-vs-server-evaluation"></a><span data-ttu-id="db1a4-102">Vyhodnocení klienta vs. serveru</span><span class="sxs-lookup"><span data-stu-id="db1a4-102">Client vs. Server Evaluation</span></span>

<span data-ttu-id="db1a4-103">Jako obecné pravidlo Entity Framework Core pokusí vyhodnotit dotaz na serveru co nejvíce.</span><span class="sxs-lookup"><span data-stu-id="db1a4-103">As a general rule, Entity Framework Core attempts to evaluate a query on the server as much as possible.</span></span> <span data-ttu-id="db1a4-104">EF Core převede části dotazu na parametry, které lze vyhodnotit na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="db1a4-104">EF Core converts parts of the query into parameters, which it can evaluate on the client side.</span></span> <span data-ttu-id="db1a4-105">Zbytek dotazu (spolu s generovanými parametry) je dán poskytovateli databáze k určení ekvivalentního databázového dotazu k vyhodnocení na serveru.</span><span class="sxs-lookup"><span data-stu-id="db1a4-105">The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server.</span></span> <span data-ttu-id="db1a4-106">EF Core podporuje částečné vyhodnocení klienta v projekci `Select()`nejvyšší úrovně (v podstatě poslední volání).</span><span class="sxs-lookup"><span data-stu-id="db1a4-106">EF Core supports partial client evaluation in the top-level projection (essentially, the last call to `Select()`).</span></span> <span data-ttu-id="db1a4-107">Pokud projekce nejvyšší úrovně v dotazu nelze přeložit na server, EF Core načte všechna požadovaná data ze serveru a vyhodnotí zbývající části dotazu na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="db1a4-107">If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client.</span></span> <span data-ttu-id="db1a4-108">Pokud EF Core zjistí výraz, na jakémkoli jiném místě než projekce nejvyšší úrovně, které nelze přeložit na server, pak vyvolá výjimku za běhu.</span><span class="sxs-lookup"><span data-stu-id="db1a4-108">If EF Core detects an expression, in any place other than the top-level projection, which can't be translated to the server, then it throws a runtime exception.</span></span> <span data-ttu-id="db1a4-109">Podívejte [se, jak funguje dotaz,](xref:core/querying/how-query-works) abyste pochopili, jak EF Core určuje, co nelze přeložit na server.</span><span class="sxs-lookup"><span data-stu-id="db1a4-109">See [how query works](xref:core/querying/how-query-works) to understand how EF Core determines what can't be translated to server.</span></span>

> [!NOTE]
> <span data-ttu-id="db1a4-110">Před verzí 3.0 core entity framework podporuje vyhodnocení klienta kdekoli v dotazu.</span><span class="sxs-lookup"><span data-stu-id="db1a4-110">Prior to version 3.0, Entity Framework Core supported client evaluation anywhere in the query.</span></span> <span data-ttu-id="db1a4-111">Další informace naleznete v [části předchozí verze](#previous-versions).</span><span class="sxs-lookup"><span data-stu-id="db1a4-111">For more information, see the [previous versions section](#previous-versions).</span></span>

> [!TIP]
> <span data-ttu-id="db1a4-112">Ukázku tohoto článku [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) můžete zobrazit na GitHubu.</span><span class="sxs-lookup"><span data-stu-id="db1a4-112">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) on GitHub.</span></span>

## <a name="client-evaluation-in-the-top-level-projection"></a><span data-ttu-id="db1a4-113">Hodnocení klienta v projekci nejvyšší úrovně</span><span class="sxs-lookup"><span data-stu-id="db1a4-113">Client evaluation in the top-level projection</span></span>

<span data-ttu-id="db1a4-114">V následujícím příkladu pomocná metoda se používá ke standardizaci adres URL pro blogy, které jsou vráceny z databáze serveru SQL Server.</span><span class="sxs-lookup"><span data-stu-id="db1a4-114">In the following example, a helper method is used to standardize URLs for blogs, which are returned from a SQL Server database.</span></span> <span data-ttu-id="db1a4-115">Vzhledem k tomu, že poskytovatel SERVERU SQL server nemá žádný přehled o tom, jak je tato metoda implementována, není možné ji přeložit do SQL.</span><span class="sxs-lookup"><span data-stu-id="db1a4-115">Since the SQL Server provider has no insight into how this method is implemented, it isn't possible to translate it into SQL.</span></span> <span data-ttu-id="db1a4-116">Všechny ostatní aspekty dotazu jsou vyhodnocovány v databázi, ale předání vrácené `URL` prostřednictvím této metody se provádí na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="db1a4-116">All other aspects of the query are evaluated in the database, but passing the returned `URL` through this method is done on the client.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientMethod)]

## <a name="unsupported-client-evaluation"></a><span data-ttu-id="db1a4-117">Nepodporované hodnocení klienta</span><span class="sxs-lookup"><span data-stu-id="db1a4-117">Unsupported client evaluation</span></span>

<span data-ttu-id="db1a4-118">Zatímco hodnocení klienta je užitečné, může mít za následek nízký výkon někdy.</span><span class="sxs-lookup"><span data-stu-id="db1a4-118">While client evaluation is useful, it can result in poor performance sometimes.</span></span> <span data-ttu-id="db1a4-119">Zvažte následující dotaz, ve kterém pomocná metoda se nyní používá v where filtr.</span><span class="sxs-lookup"><span data-stu-id="db1a4-119">Consider the following query, in which the helper method is now used in a where filter.</span></span> <span data-ttu-id="db1a4-120">Vzhledem k tomu, že filtr nelze použít v databázi, všechna data je třeba vtáhnout do paměti použít filtr na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="db1a4-120">Because the filter can't be applied in the database, all the data needs to be pulled into memory to apply the filter on the client.</span></span> <span data-ttu-id="db1a4-121">Na základě filtru a množství dat na serveru může mít hodnocení klienta za následek nízký výkon.</span><span class="sxs-lookup"><span data-stu-id="db1a4-121">Based on the filter and the amount of data on the server, client evaluation could result in poor performance.</span></span> <span data-ttu-id="db1a4-122">Takže Entity Framework Core blokuje takové vyhodnocení klienta a vyvolá výjimku za běhu.</span><span class="sxs-lookup"><span data-stu-id="db1a4-122">So Entity Framework Core blocks such client evaluation and throws a runtime exception.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientWhere)]

## <a name="explicit-client-evaluation"></a><span data-ttu-id="db1a4-123">Explicitní vyhodnocení klienta</span><span class="sxs-lookup"><span data-stu-id="db1a4-123">Explicit client evaluation</span></span>

<span data-ttu-id="db1a4-124">V některých případech, jako je sledování, může být nutné vynutit vyhodnocení klienta výslovně</span><span class="sxs-lookup"><span data-stu-id="db1a4-124">You may need to force into client evaluation explicitly in certain cases like following</span></span>

- <span data-ttu-id="db1a4-125">Množství dat je malé, takže vyhodnocení na klienta nevzniká obrovská penalizace výkonu.</span><span class="sxs-lookup"><span data-stu-id="db1a4-125">The amount of data is small so that evaluating on the client doesn't incur a huge performance penalty.</span></span>
- <span data-ttu-id="db1a4-126">Používaný operátor LINQ nemá žádný překlad na straně serveru.</span><span class="sxs-lookup"><span data-stu-id="db1a4-126">The LINQ operator being used has no server-side translation.</span></span>

<span data-ttu-id="db1a4-127">V takových případech můžete explicitně přihlásit do `AsEnumerable` `ToList` hodnocení`AsAsyncEnumerable` `ToListAsync` klienta voláním metody jako nebo (nebo pro asynchronní).</span><span class="sxs-lookup"><span data-stu-id="db1a4-127">In such cases, you can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList` (`AsAsyncEnumerable` or `ToListAsync` for async).</span></span> <span data-ttu-id="db1a4-128">Pomocí `AsEnumerable` budete streamování výsledků, ale `ToList` pomocí by způsobit ukládání do vyrovnávací paměti vytvořením seznamu, který také trvá další paměti.</span><span class="sxs-lookup"><span data-stu-id="db1a4-128">By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory.</span></span> <span data-ttu-id="db1a4-129">I když pokud jste výčet vícekrát, pak ukládání výsledků v seznamu pomáhá více, protože je pouze jeden dotaz do databáze.</span><span class="sxs-lookup"><span data-stu-id="db1a4-129">Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database.</span></span> <span data-ttu-id="db1a4-130">V závislosti na konkrétním použití byste měli vyhodnotit, která metoda je pro případ užitečnější.</span><span class="sxs-lookup"><span data-stu-id="db1a4-130">Depending on the particular usage, you should evaluate which method is more useful for the case.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ExplicitClientEval)]

## <a name="potential-memory-leak-in-client-evaluation"></a><span data-ttu-id="db1a4-131">Potenciální nevracení paměti při hodnocení klienta</span><span class="sxs-lookup"><span data-stu-id="db1a4-131">Potential memory leak in client evaluation</span></span>

<span data-ttu-id="db1a4-132">Vzhledem k tomu, že překlad dotazu a kompilace jsou nákladné, EF Core ukládá do mezipaměti zkompilovaný plán dotazů.</span><span class="sxs-lookup"><span data-stu-id="db1a4-132">Since query translation and compilation are expensive, EF Core caches the compiled query plan.</span></span> <span data-ttu-id="db1a4-133">Delegát uložený v mezipaměti může používat klientský kód při hodnocení klienta projekce nejvyšší úrovně.</span><span class="sxs-lookup"><span data-stu-id="db1a4-133">The cached delegate may use client code while doing client evaluation of top-level projection.</span></span> <span data-ttu-id="db1a4-134">EF Core generuje parametry pro klientem vyhodnocené části stromu a znovu použije plán dotazů nahrazením hodnot parametrů.</span><span class="sxs-lookup"><span data-stu-id="db1a4-134">EF Core generates parameters for the client-evaluated parts of the tree and reuses the query plan by replacing the parameter values.</span></span> <span data-ttu-id="db1a4-135">Ale určité konstanty ve stromu výrazů nelze převést na parametry.</span><span class="sxs-lookup"><span data-stu-id="db1a4-135">But certain constants in the expression tree can't be converted into parameters.</span></span> <span data-ttu-id="db1a4-136">Pokud delegát v mezipaměti obsahuje takové konstanty, pak tyto objekty nemohou být uvolněny, protože jsou stále odkazovány.</span><span class="sxs-lookup"><span data-stu-id="db1a4-136">If the cached delegate contains such constants, then those objects can't be garbage collected since they're still being referenced.</span></span> <span data-ttu-id="db1a4-137">Pokud takový objekt obsahuje DbContext nebo jiné služby v něm, pak může způsobit využití paměti aplikace růst v průběhu času.</span><span class="sxs-lookup"><span data-stu-id="db1a4-137">If such an object contains a DbContext or other services in it, then it could cause the memory usage of the app to grow over time.</span></span> <span data-ttu-id="db1a4-138">Toto chování je obecně známkou nevracení paměti.</span><span class="sxs-lookup"><span data-stu-id="db1a4-138">This behavior is generally a sign of a memory leak.</span></span> <span data-ttu-id="db1a4-139">EF Core vyvolá výjimku vždy, když narazíte na konstanty typu, který nelze namapovat pomocí aktuálního poskytovatele databáze.</span><span class="sxs-lookup"><span data-stu-id="db1a4-139">EF Core throws an exception whenever it comes across constants of a type that can't be mapped using current database provider.</span></span> <span data-ttu-id="db1a4-140">Běžné příčiny a jejich řešení jsou následující:</span><span class="sxs-lookup"><span data-stu-id="db1a4-140">Common causes and their solutions are as follows:</span></span>

- <span data-ttu-id="db1a4-141">**Použití metody instance**: Při použití metod instance v klientské projekci obsahuje strom výrazů konstantu instance.</span><span class="sxs-lookup"><span data-stu-id="db1a4-141">**Using an instance method**: When using instance methods in a client projection, the expression tree contains a constant of the instance.</span></span> <span data-ttu-id="db1a4-142">Pokud vaše metoda nepoužívá žádná data z instance, zvažte nastavení metody statické.</span><span class="sxs-lookup"><span data-stu-id="db1a4-142">If your method doesn't use any data from the instance, consider making the method static.</span></span> <span data-ttu-id="db1a4-143">Pokud potřebujete data instance v těle metody, předajte konkrétní data jako argument metodě.</span><span class="sxs-lookup"><span data-stu-id="db1a4-143">If you need instance data in the method body, then pass the specific data as an argument to the method.</span></span>
- <span data-ttu-id="db1a4-144">**Předávání konstantní argumenty metody**: Tento případ `this` vzniká obecně pomocí v argument u metody klienta.</span><span class="sxs-lookup"><span data-stu-id="db1a4-144">**Passing constant arguments to method**: This case arises generally by using `this` in an argument to client method.</span></span> <span data-ttu-id="db1a4-145">Zvažte rozdělení argumentu do více skalární argumenty, které mohou být mapovány poskytovatelem databáze.</span><span class="sxs-lookup"><span data-stu-id="db1a4-145">Consider splitting the argument in to multiple scalar arguments, which can be mapped by the database provider.</span></span>
- <span data-ttu-id="db1a4-146">**Další konstanty**: Pokud konstanta narazíte v jakémkoli jiném případě, pak můžete vyhodnotit, zda konstanta je potřeba při zpracování.</span><span class="sxs-lookup"><span data-stu-id="db1a4-146">**Other constants**: If a constant is come across in any other case, then you can evaluate whether the constant is needed in processing.</span></span> <span data-ttu-id="db1a4-147">Pokud je nutné mít konstantu nebo pokud nelze použít řešení z výše uvedených případů, vytvořte místní proměnnou pro uložení hodnoty a použití místní proměnné v dotazu.</span><span class="sxs-lookup"><span data-stu-id="db1a4-147">If it's necessary to have the constant, or if you can't use a solution from the above cases, then create a local variable to store the value and use local variable in the query.</span></span> <span data-ttu-id="db1a4-148">EF Core převede místní proměnnou na parametr.</span><span class="sxs-lookup"><span data-stu-id="db1a4-148">EF Core will convert the local variable into a parameter.</span></span>

## <a name="previous-versions"></a><span data-ttu-id="db1a4-149">Předchozí verze</span><span class="sxs-lookup"><span data-stu-id="db1a4-149">Previous versions</span></span>

<span data-ttu-id="db1a4-150">Následující část se vztahuje na verze EF Core před 3.0.</span><span class="sxs-lookup"><span data-stu-id="db1a4-150">The following section applies to EF Core versions before 3.0.</span></span>

<span data-ttu-id="db1a4-151">Starší verze EF Core podporovaly vyhodnocení klienta v libovolné části dotazu – nejen projekce nejvyšší úrovně.</span><span class="sxs-lookup"><span data-stu-id="db1a4-151">Older EF Core versions supported client evaluation in any part of the query--not just the top-level projection.</span></span> <span data-ttu-id="db1a4-152">To je důvod, proč dotazy podobné jednomu zaúčtované v části [Hodnocení nepodporovaného klienta](#unsupported-client-evaluation) fungovaly správně.</span><span class="sxs-lookup"><span data-stu-id="db1a4-152">That's why queries similar to one posted under the [Unsupported client evaluation](#unsupported-client-evaluation) section worked correctly.</span></span> <span data-ttu-id="db1a4-153">Vzhledem k tomu, že toto chování může způsobit problémy s výkonem bez povšimnutí, EF Core zaznamenal upozornění na vyhodnocení klienta.</span><span class="sxs-lookup"><span data-stu-id="db1a4-153">Since this behavior could cause unnoticed performance issues, EF Core logged a client evaluation warning.</span></span> <span data-ttu-id="db1a4-154">Další informace o zobrazení výstupu protokolování naleznete v [tématu Protokolování](xref:core/miscellaneous/logging).</span><span class="sxs-lookup"><span data-stu-id="db1a4-154">For more information on viewing logging output, see [Logging](xref:core/miscellaneous/logging).</span></span>

<span data-ttu-id="db1a4-155">Volitelně EF Core umožňuje změnit výchozí chování buď vyvolat výjimku nebo nedělat nic při hodnocení klienta (s výjimkou v projekci).</span><span class="sxs-lookup"><span data-stu-id="db1a4-155">Optionally EF Core allowed you to change the default behavior to either throw an exception or do nothing when doing client evaluation (except for in the projection).</span></span> <span data-ttu-id="db1a4-156">Chování vyvolání výjimky by bylo podobné chování v 3.0.</span><span class="sxs-lookup"><span data-stu-id="db1a4-156">The exception throwing behavior would make it similar to the behavior in 3.0.</span></span> <span data-ttu-id="db1a4-157">Chcete-li změnit chování, je třeba nakonfigurovat upozornění při nastavování možností pro váš kontext – obvykle v `DbContext.OnConfiguring`aplikaci nebo v `Startup.cs` aplikaci, pokud používáte ASP.NET core.</span><span class="sxs-lookup"><span data-stu-id="db1a4-157">To change the behavior, you need to configure warnings while setting up the options for your context - typically in `DbContext.OnConfiguring`, or in `Startup.cs` if you're using ASP.NET Core.</span></span>

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=EFQuerying;Trusted_Connection=True;")
        .ConfigureWarnings(warnings => warnings.Throw(RelationalEventId.QueryClientEvaluationWarning));
}
```
