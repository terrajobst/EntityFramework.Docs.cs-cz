---
title: Upgrade z předchozích verzí na EF Core 2 – EF Core
author: divega
ms.date: 08/13/2017
ms.assetid: 8BD43C8C-63D9-4F3A-B954-7BC518A1B7DB
uid: core/miscellaneous/1x-2x-upgrade
ms.openlocfilehash: 42e59b47f569ef6fcf72fc5bd5f94d3e9d807a24
ms.sourcegitcommit: 6c28926a1e35e392b198a8729fc13c1c1968a27b
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/02/2019
ms.locfileid: "71813573"
---
# <a name="upgrading-applications-from-previous-versions-to-ef-core-20"></a><span data-ttu-id="2e404-102">Upgrade aplikací z předchozích verzí na EF Core 2,0</span><span class="sxs-lookup"><span data-stu-id="2e404-102">Upgrading applications from previous versions to EF Core 2.0</span></span>

<span data-ttu-id="2e404-103">Máme příležitost významně vylepšit naše existující rozhraní API a chování v 2,0.</span><span class="sxs-lookup"><span data-stu-id="2e404-103">We have taken the opportunity to significantly refine our existing APIs and behaviors in 2.0.</span></span> <span data-ttu-id="2e404-104">Existuje několik vylepšení, která mohou vyžadovat úpravu stávajícího kódu aplikace, i když se domníváme, že většina aplikací bude mít dopad na nízký výkon, ve většině případů, kdy je potřeba pouze opětovná kompilace a minimální změny Průvodce pro nahrazení zastaralých rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="2e404-104">There are a few improvements that can require modifying existing application code, although we believe that for the majority of applications the impact will be low, in most cases requiring just recompilation and minimal guided changes to replace obsolete APIs.</span></span>

<span data-ttu-id="2e404-105">Aktualizace existující aplikace na EF Core 2,0 může vyžadovat:</span><span class="sxs-lookup"><span data-stu-id="2e404-105">Updating an existing application to EF Core 2.0 may require:</span></span>

1. <span data-ttu-id="2e404-106">Upgrade cílové implementace .NET aplikace na jednu, která podporuje .NET Standard 2,0.</span><span class="sxs-lookup"><span data-stu-id="2e404-106">Upgrading the target .NET implementation of the application to one that supports .NET Standard 2.0.</span></span> <span data-ttu-id="2e404-107">Další podrobnosti najdete v tématu [podporované implementace rozhraní .NET](../platforms/index.md) .</span><span class="sxs-lookup"><span data-stu-id="2e404-107">See [Supported .NET Implementations](../platforms/index.md) for more details.</span></span>

2. <span data-ttu-id="2e404-108">Identifikujte poskytovatele cílové databáze, který je kompatibilní s EF Core 2,0.</span><span class="sxs-lookup"><span data-stu-id="2e404-108">Identify a provider for the target database which is compatible with EF Core 2.0.</span></span> <span data-ttu-id="2e404-109">Viz [EF Core 2,0 vyžaduje níže uvedený zprostředkovatel databáze 2,0](#ef-core-20-requires-a-20-database-provider) .</span><span class="sxs-lookup"><span data-stu-id="2e404-109">See [EF Core 2.0 requires a 2.0 database provider](#ef-core-20-requires-a-20-database-provider) below.</span></span>

3. <span data-ttu-id="2e404-110">Upgradují se všechny balíčky EF Core (běhové prostředí a nástroje) na 2,0.</span><span class="sxs-lookup"><span data-stu-id="2e404-110">Upgrading all the EF Core packages (runtime and tooling) to 2.0.</span></span> <span data-ttu-id="2e404-111">Další podrobnosti najdete v tématu [instalace EF Core](../get-started/install/index.md) .</span><span class="sxs-lookup"><span data-stu-id="2e404-111">Refer to [Installing EF Core](../get-started/install/index.md) for more details.</span></span>

4. <span data-ttu-id="2e404-112">Proveďte potřebné změny kódu, abyste mohli kompenzovat zásadní změny popsané ve zbývající části tohoto dokumentu.</span><span class="sxs-lookup"><span data-stu-id="2e404-112">Make any necessary code changes to compensate for the breaking changes described in the rest of this document.</span></span>

## <a name="aspnet-core-now-includes-ef-core"></a><span data-ttu-id="2e404-113">ASP.NET Core nyní zahrnuje EF Core</span><span class="sxs-lookup"><span data-stu-id="2e404-113">ASP.NET Core now includes EF Core</span></span>

<span data-ttu-id="2e404-114">Aplikace cílené na ASP.NET Core 2,0 mohou používat EF Core 2,0 bez dalších závislostí kromě poskytovatelů databáze třetích stran.</span><span class="sxs-lookup"><span data-stu-id="2e404-114">Applications targeting ASP.NET Core 2.0 can use EF Core 2.0 without additional dependencies besides third party database providers.</span></span> <span data-ttu-id="2e404-115">Avšak aplikace cílené na předchozí verze ASP.NET Core nutné upgradovat na ASP.NET Core 2,0, aby bylo možné použít EF Core 2,0.</span><span class="sxs-lookup"><span data-stu-id="2e404-115">However, applications targeting previous versions of ASP.NET Core need to upgrade to ASP.NET Core 2.0 in order to use EF Core 2.0.</span></span> <span data-ttu-id="2e404-116">Další podrobnosti o upgradu ASP.NET Corech aplikací na 2,0 najdete v [dokumentaci k ASP.NET Core na daném předmětu](https://docs.microsoft.com/aspnet/core/migration/1x-to-2x/).</span><span class="sxs-lookup"><span data-stu-id="2e404-116">For more details on upgrading ASP.NET Core applications to 2.0 see [the ASP.NET Core documentation on the subject](https://docs.microsoft.com/aspnet/core/migration/1x-to-2x/).</span></span>

## <a name="new-way-of-getting-application-services-in-aspnet-core"></a><span data-ttu-id="2e404-117">Nový způsob získání aplikačních služeb v ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="2e404-117">New way of getting application services in ASP.NET Core</span></span>

<span data-ttu-id="2e404-118">Doporučený vzor pro ASP.NET Core webové aplikace byl aktualizován pro 2,0 způsobem, který podařilo přerušit logiku návrhu EF Core použitou v 1. x.</span><span class="sxs-lookup"><span data-stu-id="2e404-118">The recommended pattern for ASP.NET Core web applications has been updated for 2.0 in a way that broke the design-time logic EF Core used in 1.x.</span></span> <span data-ttu-id="2e404-119">Dříve v době návrhu EF Core pokus o vyvolání `Startup.ConfigureServices` přímo za účelem přístupu k poskytovateli služeb aplikace.</span><span class="sxs-lookup"><span data-stu-id="2e404-119">Previously at design-time, EF Core would try to invoke `Startup.ConfigureServices` directly in order to access the application's service provider.</span></span> <span data-ttu-id="2e404-120">V ASP.NET Core 2,0 je konfigurace inicializována mimo `Startup` třídu.</span><span class="sxs-lookup"><span data-stu-id="2e404-120">In ASP.NET Core 2.0, Configuration is initialized outside of the `Startup` class.</span></span> <span data-ttu-id="2e404-121">Aplikace používající EF Core obvykle ke svému připojovacímu řetězci přistupuje z konfigurace `Startup` , takže sám o sobě nestačí.</span><span class="sxs-lookup"><span data-stu-id="2e404-121">Applications using EF Core typically access their connection string from Configuration, so `Startup` by itself is no longer sufficient.</span></span> <span data-ttu-id="2e404-122">Pokud upgradujete ASP.NET Core 1. x aplikace, může se při použití EF Core nástrojů zobrazit následující chyba.</span><span class="sxs-lookup"><span data-stu-id="2e404-122">If you upgrade an ASP.NET Core 1.x application, you may receive the following error when using the EF Core tools.</span></span>

> <span data-ttu-id="2e404-123">V ' ApplicationContext ' nebyl nalezen žádný konstruktor bez parametrů.</span><span class="sxs-lookup"><span data-stu-id="2e404-123">No parameterless constructor was found on 'ApplicationContext'.</span></span> <span data-ttu-id="2e404-124">Buď přidejte konstruktor bez parametrů do ' ApplicationContext ' nebo přidejte implementaci ' IDesignTimeDbContextFactory&lt;ApplicationContext&gt;' do stejného sestavení jako ' ApplicationContext '</span><span class="sxs-lookup"><span data-stu-id="2e404-124">Either add a parameterless constructor to 'ApplicationContext' or add an implementation of 'IDesignTimeDbContextFactory&lt;ApplicationContext&gt;' in the same assembly as 'ApplicationContext'</span></span>

<span data-ttu-id="2e404-125">Do výchozí šablony ASP.NET Core 2.0 byl přidán nový přidaný čas návrhu.</span><span class="sxs-lookup"><span data-stu-id="2e404-125">A new design-time hook has been added in ASP.NET Core 2.0's default template.</span></span> <span data-ttu-id="2e404-126">Statická `Program.BuildWebHost` metoda umožňuje EF Core přistupovat k poskytovateli služeb aplikace v době návrhu.</span><span class="sxs-lookup"><span data-stu-id="2e404-126">The static `Program.BuildWebHost` method enables EF Core to access the application's service provider at design time.</span></span> <span data-ttu-id="2e404-127">Pokud upgradujete ASP.NET Core 1. x aplikace, budete muset `Program` třídu aktualizovat tak, aby vypadala jako následující.</span><span class="sxs-lookup"><span data-stu-id="2e404-127">If you are upgrading an ASP.NET Core 1.x application, you will need to update the `Program` class to resemble the following.</span></span>

``` csharp
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Hosting;

namespace AspNetCoreDotNetCore2._0App
{
    public class Program
    {
        public static void Main(string[] args)
        {
            BuildWebHost(args).Run();
        }

        public static IWebHost BuildWebHost(string[] args) =>
            WebHost.CreateDefaultBuilder(args)
                .UseStartup<Startup>()
                .Build();
    }
}
```

<span data-ttu-id="2e404-128">Přijetí tohoto nového vzoru, když se aktualizuje aplikace na 2,0, se důrazně doporučuje a je potřeba, aby se funkce produktu, jako Entity Framework Core migrace, daly pracovat.</span><span class="sxs-lookup"><span data-stu-id="2e404-128">The adoption of this new pattern when updating applications to 2.0 is highly recommended and is required in order for product features like Entity Framework Core Migrations to work.</span></span> <span data-ttu-id="2e404-129">Další běžnou alternativou je [implementace *IDesignTimeDbContextFactory\<TContext >* ](xref:core/miscellaneous/cli/dbcontext-creation#from-a-design-time-factory).</span><span class="sxs-lookup"><span data-stu-id="2e404-129">The other common alternative is to [implement *IDesignTimeDbContextFactory\<TContext>*](xref:core/miscellaneous/cli/dbcontext-creation#from-a-design-time-factory).</span></span>

## <a name="idbcontextfactory-renamed"></a><span data-ttu-id="2e404-130">Přejmenované IDbContextFactory</span><span class="sxs-lookup"><span data-stu-id="2e404-130">IDbContextFactory renamed</span></span>

<span data-ttu-id="2e404-131">Aby bylo možné podporovat různé vzorce aplikací a poskytnout uživatelům větší kontrolu nad tím `DbContext` `IDbContextFactory<TContext>` , jak se používají v době návrhu, máme v minulosti za rozhraní.</span><span class="sxs-lookup"><span data-stu-id="2e404-131">In order to support diverse application patterns and give users more control over how their `DbContext` is used at design time, we have, in the past, provided the `IDbContextFactory<TContext>` interface.</span></span> <span data-ttu-id="2e404-132">V době návrhu budou EF Core nástroje ve vašem projektu zjišťovat implementace tohoto rozhraní a použít ho k vytvoření `DbContext` objektů.</span><span class="sxs-lookup"><span data-stu-id="2e404-132">At design-time, the EF Core tools will discover implementations of this interface in your project and use it to create `DbContext` objects.</span></span>

<span data-ttu-id="2e404-133">Toto rozhraní má velmi obecný název, který je v omylu pro uživatele, kteří si ho můžou `DbContext`zkusit znovu použít pro jiné scénáře vytváření.</span><span class="sxs-lookup"><span data-stu-id="2e404-133">This interface had a very general name which mislead some users to try re-using it for other `DbContext`-creating scenarios.</span></span> <span data-ttu-id="2e404-134">Odcházejí z ochrany, když se nástroje EF potom pokusily použít jejich implementaci v době návrhu a způsobily selhání příkazů `Update-Database` , `dotnet ef database update` jako je nebo chyba.</span><span class="sxs-lookup"><span data-stu-id="2e404-134">They were caught off guard when the EF Tools then tried to use their implementation at design-time and caused commands like `Update-Database` or `dotnet ef database update` to fail.</span></span>

<span data-ttu-id="2e404-135">Abychom mohli sdělit silný sémantiku tohoto rozhraní v době návrhu, přejmenovali jsme ho na `IDesignTimeDbContextFactory<TContext>`.</span><span class="sxs-lookup"><span data-stu-id="2e404-135">In order to communicate the strong design-time semantics of this interface, we have renamed it to `IDesignTimeDbContextFactory<TContext>`.</span></span>

<span data-ttu-id="2e404-136">Pro vydání 2,0 verze `IDbContextFactory<TContext>` stále existuje, ale je označena jako zastaralá.</span><span class="sxs-lookup"><span data-stu-id="2e404-136">For the 2.0 release the `IDbContextFactory<TContext>` still exists but is marked as obsolete.</span></span>

## <a name="dbcontextfactoryoptions-removed"></a><span data-ttu-id="2e404-137">DbContextFactoryOptions odebrané</span><span class="sxs-lookup"><span data-stu-id="2e404-137">DbContextFactoryOptions removed</span></span>

<span data-ttu-id="2e404-138">Vzhledem k tomu, že se výše popsané změny ASP.NET Core 2,0, `DbContextFactoryOptions` zjistili jsme, že už na novém `IDesignTimeDbContextFactory<TContext>` rozhraní nepotřebujeme.</span><span class="sxs-lookup"><span data-stu-id="2e404-138">Because of the ASP.NET Core 2.0 changes described above, we found that `DbContextFactoryOptions` was no longer needed on the new `IDesignTimeDbContextFactory<TContext>` interface.</span></span> <span data-ttu-id="2e404-139">Tady jsou alternativy, které byste měli použít místo toho.</span><span class="sxs-lookup"><span data-stu-id="2e404-139">Here are the alternatives you should be using instead.</span></span>

| <span data-ttu-id="2e404-140">DbContextFactoryOptions</span><span class="sxs-lookup"><span data-stu-id="2e404-140">DbContextFactoryOptions</span></span> | <span data-ttu-id="2e404-141">Jiné</span><span class="sxs-lookup"><span data-stu-id="2e404-141">Alternative</span></span>                                                  |
|:------------------------|:-------------------------------------------------------------|
| <span data-ttu-id="2e404-142">ApplicationBasePath</span><span class="sxs-lookup"><span data-stu-id="2e404-142">ApplicationBasePath</span></span>     | <span data-ttu-id="2e404-143">AppContext. BaseDirectory</span><span class="sxs-lookup"><span data-stu-id="2e404-143">AppContext.BaseDirectory</span></span>                                     |
| <span data-ttu-id="2e404-144">ContentRootPath</span><span class="sxs-lookup"><span data-stu-id="2e404-144">ContentRootPath</span></span>         | <span data-ttu-id="2e404-145">Directory.GetCurrentDirectory()</span><span class="sxs-lookup"><span data-stu-id="2e404-145">Directory.GetCurrentDirectory()</span></span>                              |
| <span data-ttu-id="2e404-146">EnvironmentName</span><span class="sxs-lookup"><span data-stu-id="2e404-146">EnvironmentName</span></span>         | <span data-ttu-id="2e404-147">Environment. GetEnvironmentVariable ("ASPNETCORE_ENVIRONMENT")</span><span class="sxs-lookup"><span data-stu-id="2e404-147">Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT")</span></span> |

## <a name="design-time-working-directory-changed"></a><span data-ttu-id="2e404-148">Pracovní adresář v době návrhu se změnil.</span><span class="sxs-lookup"><span data-stu-id="2e404-148">Design-time working directory changed</span></span>

<span data-ttu-id="2e404-149">Změny ASP.NET Core 2,0 také vyžadují pracovní adresář používaný nástrojem `dotnet ef` k zarovnávání s pracovním adresářem používaným sadou Visual Studio při spuštění aplikace.</span><span class="sxs-lookup"><span data-stu-id="2e404-149">The ASP.NET Core 2.0 changes also required the working directory used by `dotnet ef` to align with the working directory used by Visual Studio when running your application.</span></span> <span data-ttu-id="2e404-150">Jedním z podobných vedlejších účinků je, že názvy souborů SQLite jsou nyní relativní vzhledem k adresáři projektu, a nikoli výstupní adresář, jako by se použily.</span><span class="sxs-lookup"><span data-stu-id="2e404-150">One observable side effect of this is that SQLite filenames are now relative to the project directory and not the output directory like they used to be.</span></span>

## <a name="ef-core-20-requires-a-20-database-provider"></a><span data-ttu-id="2e404-151">EF Core 2,0 vyžaduje poskytovatele databáze 2,0.</span><span class="sxs-lookup"><span data-stu-id="2e404-151">EF Core 2.0 requires a 2.0 database provider</span></span>

<span data-ttu-id="2e404-152">Pro EF Core 2,0 jsme provedli mnoho zjednodušení a vylepšení, jak fungují poskytovatelé databáze.</span><span class="sxs-lookup"><span data-stu-id="2e404-152">For EF Core 2.0 we have made many simplifications and improvements in the way database providers work.</span></span> <span data-ttu-id="2e404-153">To znamená, že zprostředkovatelé 1.0. x a 1.1. x nebudou fungovat s EF Core 2,0.</span><span class="sxs-lookup"><span data-stu-id="2e404-153">This means that 1.0.x and 1.1.x providers will not work with EF Core 2.0.</span></span>

<span data-ttu-id="2e404-154">Poskytovatelé SQL Server a SQLite jsou dodány týmem EF a verze 2,0 budou k dispozici jako součást verze 2,0.</span><span class="sxs-lookup"><span data-stu-id="2e404-154">The SQL Server and SQLite providers are shipped by the EF team and 2.0 versions will be available as part of the 2.0 release.</span></span> <span data-ttu-id="2e404-155">Open Source poskytovatelé třetích stran pro [SQL Compact](https://github.com/ErikEJ/EntityFramework.SqlServerCompact), [PostgreSQL](https://github.com/npgsql/Npgsql.EntityFrameworkCore.PostgreSQL)a [MySQL](https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.MySql) se aktualizují na 2,0.</span><span class="sxs-lookup"><span data-stu-id="2e404-155">The open-source third party providers for [SQL Compact](https://github.com/ErikEJ/EntityFramework.SqlServerCompact), [PostgreSQL](https://github.com/npgsql/Npgsql.EntityFrameworkCore.PostgreSQL), and [MySQL](https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.MySql) are being updated for 2.0.</span></span> <span data-ttu-id="2e404-156">U všech ostatních zprostředkovatelů se prosím obraťte na zapisovač poskytovatele.</span><span class="sxs-lookup"><span data-stu-id="2e404-156">For all other providers, please contact the provider writer.</span></span>

## <a name="logging-and-diagnostics-events-have-changed"></a><span data-ttu-id="2e404-157">Události protokolování a diagnostiky se změnily.</span><span class="sxs-lookup"><span data-stu-id="2e404-157">Logging and Diagnostics events have changed</span></span>

<span data-ttu-id="2e404-158">Poznámka: tyto změny by neměly mít vliv na většinu kódu aplikace.</span><span class="sxs-lookup"><span data-stu-id="2e404-158">Note: these changes should not impact most application code.</span></span>

<span data-ttu-id="2e404-159">ID událostí pro zprávy odeslané do [ILogger](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger) se změnila v 2,0.</span><span class="sxs-lookup"><span data-stu-id="2e404-159">The event IDs for messages sent to an [ILogger](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger) have changed in 2.0.</span></span> <span data-ttu-id="2e404-160">Identifikátory událostí jsou teď v rámci EF Core kódu jedinečné.</span><span class="sxs-lookup"><span data-stu-id="2e404-160">The event IDs are now unique across EF Core code.</span></span> <span data-ttu-id="2e404-161">Tyto zprávy se teď také řídí standardním vzorem pro strukturované protokolování, které používá, například MVC.</span><span class="sxs-lookup"><span data-stu-id="2e404-161">These messages now also follow the standard pattern for structured logging used by, for example, MVC.</span></span>

<span data-ttu-id="2e404-162">Změnily se také kategorie protokolovacího nástroje.</span><span class="sxs-lookup"><span data-stu-id="2e404-162">Logger categories have also changed.</span></span> <span data-ttu-id="2e404-163">K dispozici je teď známá sada kategorií, ke které se dostanete prostřednictvím [DbLoggerCategory](https://github.com/aspnet/EntityFrameworkCore/blob/rel/2.0.0/src/EFCore/DbLoggerCategory.cs).</span><span class="sxs-lookup"><span data-stu-id="2e404-163">There is now a well-known set of categories accessed through [DbLoggerCategory](https://github.com/aspnet/EntityFrameworkCore/blob/rel/2.0.0/src/EFCore/DbLoggerCategory.cs).</span></span>

<span data-ttu-id="2e404-164">Události [DiagnosticSource](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md) nyní používají stejné názvy ID události jako odpovídající `ILogger` zprávy.</span><span class="sxs-lookup"><span data-stu-id="2e404-164">[DiagnosticSource](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md) events now use the same event ID names as the corresponding `ILogger` messages.</span></span> <span data-ttu-id="2e404-165">Datové části událostí jsou všechny nominální typy odvozené z [EventData](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.diagnostics.eventdata).</span><span class="sxs-lookup"><span data-stu-id="2e404-165">The event payloads are all nominal types derived from [EventData](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.diagnostics.eventdata).</span></span>

<span data-ttu-id="2e404-166">ID událostí, typy datových částí a kategorie jsou zdokumentovány v [CoreEventId](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.diagnostics.coreeventid) a třídách [RelationalEventId](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.diagnostics.relationaleventid) .</span><span class="sxs-lookup"><span data-stu-id="2e404-166">Event IDs, payload types, and categories are documented in the [CoreEventId](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.diagnostics.coreeventid) and the [RelationalEventId](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.diagnostics.relationaleventid) classes.</span></span>

<span data-ttu-id="2e404-167">ID se také přesunula z Microsoft. EntityFrameworkCore. Infrastructure na nový obor názvů Microsoft. EntityFrameworkCore. Diagnostics.</span><span class="sxs-lookup"><span data-stu-id="2e404-167">IDs have also moved from Microsoft.EntityFrameworkCore.Infrastructure to the new Microsoft.EntityFrameworkCore.Diagnostics namespace.</span></span>

## <a name="ef-core-relational-metadata-api-changes"></a><span data-ttu-id="2e404-168">EF Core změny v rozhraní API relačních metadat</span><span class="sxs-lookup"><span data-stu-id="2e404-168">EF Core relational metadata API changes</span></span>

<span data-ttu-id="2e404-169">EF Core 2,0 teď pro každého jiného zprostředkovatele vytvoří jiný [IModel](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.imodel) .</span><span class="sxs-lookup"><span data-stu-id="2e404-169">EF Core 2.0 will now build a different [IModel](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.imodel) for each different provider being used.</span></span> <span data-ttu-id="2e404-170">To je obvykle transparentní pro aplikaci.</span><span class="sxs-lookup"><span data-stu-id="2e404-170">This is usually transparent to the application.</span></span> <span data-ttu-id="2e404-171">Usnadnili jsme tak zjednodušení rozhraní API na nižší úrovni tak, aby jakýkoliv přístup k _běžným koncepcím relačních metadat_ byl vždy proveden prostřednictvím volání `.Relational` namísto `.SqlServer`, `.Sqlite`atd. Například kód 1.1. x podobný tomuto:</span><span class="sxs-lookup"><span data-stu-id="2e404-171">This has facilitated a simplification of lower-level metadata APIs such that any access to _common relational metadata concepts_ is always made through a call to `.Relational` instead of `.SqlServer`, `.Sqlite`, etc. For example, 1.1.x code like this:</span></span>

``` csharp
var tableName = context.Model.FindEntityType(typeof(User)).SqlServer().TableName;
```

<span data-ttu-id="2e404-172">By teď mělo být zapsáno takto:</span><span class="sxs-lookup"><span data-stu-id="2e404-172">Should now be written like this:</span></span>

``` csharp
var tableName = context.Model.FindEntityType(typeof(User)).Relational().TableName;
```

<span data-ttu-id="2e404-173">Namísto použití metod jako `ForSqlServerToTable`jsou nyní k dispozici metody rozšíření pro zápis podmíněného kódu na základě aktuálně používaného poskytovatele.</span><span class="sxs-lookup"><span data-stu-id="2e404-173">Instead of using methods like `ForSqlServerToTable`, extension methods are now available to write conditional code based on the current provider in use.</span></span> <span data-ttu-id="2e404-174">Příklad:</span><span class="sxs-lookup"><span data-stu-id="2e404-174">For example:</span></span>

```C#
modelBuilder.Entity<User>().ToTable(
    Database.IsSqlServer() ? "SqlServerName" : "OtherName");
```

<span data-ttu-id="2e404-175">Tato změna se vztahuje pouze na rozhraní API/metadata, která jsou definována pro _všechny_ relační zprostředkovatele.</span><span class="sxs-lookup"><span data-stu-id="2e404-175">Note that this change only applies to APIs/metadata that is defined for _all_ relational providers.</span></span> <span data-ttu-id="2e404-176">Rozhraní API a metadata zůstávají stejné, pokud jsou specifické jenom pro jednoho poskytovatele.</span><span class="sxs-lookup"><span data-stu-id="2e404-176">The API and metadata remains the same when it is specific to only a single provider.</span></span> <span data-ttu-id="2e404-177">Například clusterované indexy jsou specifické pro SQL Server, takže `ForSqlServerIsClustered` a `.SqlServer().IsClustered()` musí se dál používat.</span><span class="sxs-lookup"><span data-stu-id="2e404-177">For example, clustered indexes are specific to SQL Sever, so `ForSqlServerIsClustered` and  `.SqlServer().IsClustered()` must still be used.</span></span>

## <a name="dont-take-control-of-the-ef-service-provider"></a><span data-ttu-id="2e404-178">Nepřevzít kontrolu nad poskytovatelem služby EF</span><span class="sxs-lookup"><span data-stu-id="2e404-178">Don’t take control of the EF service provider</span></span>

<span data-ttu-id="2e404-179">EF Core pro svou interní `IServiceProvider` implementaci používá interní (kontejner vkládání s závislostmi).</span><span class="sxs-lookup"><span data-stu-id="2e404-179">EF Core uses an internal `IServiceProvider` (a dependency injection container) for its internal implementation.</span></span> <span data-ttu-id="2e404-180">Aplikace by měly EF Core vytvářet a spravovat tohoto poskytovatele s výjimkou zvláštních případů.</span><span class="sxs-lookup"><span data-stu-id="2e404-180">Applications should allow EF Core to create and manage this provider except in special cases.</span></span> <span data-ttu-id="2e404-181">Důrazně zvažte odebrání všech volání `UseInternalServiceProvider`.</span><span class="sxs-lookup"><span data-stu-id="2e404-181">Strongly consider removing any calls to `UseInternalServiceProvider`.</span></span> <span data-ttu-id="2e404-182">Pokud aplikace vyžaduje volání `UseInternalServiceProvider`, zvažte, jestli je potřeba nahlásit [problém](https://github.com/aspnet/EntityFramework/Issues) , abychom mohli prozkoumat další způsoby, jak váš scénář zpracovat.</span><span class="sxs-lookup"><span data-stu-id="2e404-182">If an application does need to call `UseInternalServiceProvider`, then please consider [filing an issue](https://github.com/aspnet/EntityFramework/Issues) so we can investigate other ways to handle your scenario.</span></span>

<span data-ttu-id="2e404-183">Volání `AddEntityFramework`, `AddEntityFrameworkSqlServer`, atd. není vyžadováno kódem aplikace, pokud `UseInternalServiceProvider` není volána také metoda.</span><span class="sxs-lookup"><span data-stu-id="2e404-183">Calling `AddEntityFramework`, `AddEntityFrameworkSqlServer`, etc. is not required by application code unless `UseInternalServiceProvider` is also called.</span></span> <span data-ttu-id="2e404-184">Odeberte všechna existující volání `AddEntityFramework` nebo `AddEntityFrameworkSqlServer`atd. `AddDbContext` by měla být použita stejným způsobem jako předtím.</span><span class="sxs-lookup"><span data-stu-id="2e404-184">Remove any existing calls to `AddEntityFramework` or `AddEntityFrameworkSqlServer`, etc. `AddDbContext` should still be used in the same way as before.</span></span>

## <a name="in-memory-databases-must-be-named"></a><span data-ttu-id="2e404-185">Databáze v paměti musí mít název.</span><span class="sxs-lookup"><span data-stu-id="2e404-185">In-memory databases must be named</span></span>

<span data-ttu-id="2e404-186">Globální Nepojmenovaná databáze v paměti byla odebrána a místo toho musí být všechny databáze v paměti pojmenovány.</span><span class="sxs-lookup"><span data-stu-id="2e404-186">The global unnamed in-memory database has been removed and instead all in-memory databases must be named.</span></span> <span data-ttu-id="2e404-187">Příklad:</span><span class="sxs-lookup"><span data-stu-id="2e404-187">For example:</span></span>

``` csharp
optionsBuilder.UseInMemoryDatabase("MyDatabase");
```

<span data-ttu-id="2e404-188">Tím se vytvoří nebo použije databáze s názvem "MyDatabase".</span><span class="sxs-lookup"><span data-stu-id="2e404-188">This creates/uses a database with the name “MyDatabase”.</span></span> <span data-ttu-id="2e404-189">Pokud `UseInMemoryDatabase` je volána znovu se stejným názvem, bude použita stejná databáze v paměti, což umožňuje sdílení více instancí kontextu.</span><span class="sxs-lookup"><span data-stu-id="2e404-189">If `UseInMemoryDatabase` is called again with the same name, then the same in-memory database will be used, allowing it to be shared by multiple context instances.</span></span>

## <a name="read-only-api-changes"></a><span data-ttu-id="2e404-190">Změny rozhraní API jen pro čtení</span><span class="sxs-lookup"><span data-stu-id="2e404-190">Read-only API changes</span></span>

<span data-ttu-id="2e404-191">`IsReadOnlyBeforeSave`, `IsReadOnlyAfterSave`a `IsStoreGeneratedAlways` byly zastaralé a nahrazeny [BeforeSaveBehavior](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.iproperty.beforesavebehavior) a [AfterSaveBehavior](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.iproperty.aftersavebehavior).</span><span class="sxs-lookup"><span data-stu-id="2e404-191">`IsReadOnlyBeforeSave`, `IsReadOnlyAfterSave`, and `IsStoreGeneratedAlways` have been obsoleted and replaced with [BeforeSaveBehavior](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.iproperty.beforesavebehavior) and [AfterSaveBehavior](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.iproperty.aftersavebehavior).</span></span> <span data-ttu-id="2e404-192">Toto chování platí pro libovolnou vlastnost (nikoli pouze vlastnosti generované úložištěm) a určuje, jak má být hodnota vlastnosti použita při vložení do řádku databáze (`BeforeSaveBehavior`) nebo při aktualizaci stávajícího řádku databáze (`AfterSaveBehavior`).</span><span class="sxs-lookup"><span data-stu-id="2e404-192">These behaviors apply to any property (not only store-generated properties) and determine how the value of the property should be used when inserting into a database row (`BeforeSaveBehavior`) or when updating an existing database row (`AfterSaveBehavior`).</span></span>

<span data-ttu-id="2e404-193">Vlastnosti označené jako [ValueGenerated. OnAddOrUpdate](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.valuegenerated) (například pro počítané sloupce) budou ve výchozím nastavení ignorovat všechny hodnoty aktuálně nastavené u vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="2e404-193">Properties marked as [ValueGenerated.OnAddOrUpdate](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.valuegenerated) (for example, for computed columns) will by default ignore any value currently set on the property.</span></span> <span data-ttu-id="2e404-194">To znamená, že hodnota generovaná úložištěm bude vždycky získaná bez ohledu na to, jestli se pro sledovanou entitu nastavila nebo změnila nějaká hodnota.</span><span class="sxs-lookup"><span data-stu-id="2e404-194">This means that a store-generated value will always be obtained regardless of whether any value has been set or modified on the tracked entity.</span></span> <span data-ttu-id="2e404-195">To lze změnit nastavením jiného `Before\AfterSaveBehavior`.</span><span class="sxs-lookup"><span data-stu-id="2e404-195">This can be changed by setting a different `Before\AfterSaveBehavior`.</span></span>

## <a name="new-clientsetnull-delete-behavior"></a><span data-ttu-id="2e404-196">Nové chování při odstraňování ClientSetNull</span><span class="sxs-lookup"><span data-stu-id="2e404-196">New ClientSetNull delete behavior</span></span>

<span data-ttu-id="2e404-197">V předchozích verzích měla [DeleteBehavior. restrict](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.deletebehavior) chování pro entity sledované kontextem, který je více uzavřenou `SetNull` shodnou sémantikou.</span><span class="sxs-lookup"><span data-stu-id="2e404-197">In previous releases, [DeleteBehavior.Restrict](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.deletebehavior) had a behavior for entities tracked by the context that more closed matched `SetNull` semantics.</span></span> <span data-ttu-id="2e404-198">V EF Core 2,0 byl pro volitelné `ClientSetNull` relace zaveden nové chování jako výchozí.</span><span class="sxs-lookup"><span data-stu-id="2e404-198">In EF Core 2.0, a new `ClientSetNull` behavior has been introduced as the default for optional relationships.</span></span> <span data-ttu-id="2e404-199">Toto chování má `SetNull` sémantiku pro sledované entity a `Restrict` chování pro databáze vytvořené pomocí EF Core.</span><span class="sxs-lookup"><span data-stu-id="2e404-199">This behavior has `SetNull` semantics for tracked entities and `Restrict` behavior for databases created using EF Core.</span></span> <span data-ttu-id="2e404-200">V našem prostředí se jedná o nejpravděpodobnější/užitečné chování sledovaných entit a databáze.</span><span class="sxs-lookup"><span data-stu-id="2e404-200">In our experience, these are the most expected/useful behaviors for tracked entities and the database.</span></span> <span data-ttu-id="2e404-201">`DeleteBehavior.Restrict`se teď u sledovaných entit dodrží při nastavení pro volitelné vztahy.</span><span class="sxs-lookup"><span data-stu-id="2e404-201">`DeleteBehavior.Restrict` is now honored for tracked entities when set for optional relationships.</span></span>

## <a name="provider-design-time-packages-removed"></a><span data-ttu-id="2e404-202">Odebrané balíčky pro dobu návrhu zprostředkovatele</span><span class="sxs-lookup"><span data-stu-id="2e404-202">Provider design-time packages removed</span></span>

<span data-ttu-id="2e404-203">`Microsoft.EntityFrameworkCore.Relational.Design` Balíček se odebral.</span><span class="sxs-lookup"><span data-stu-id="2e404-203">The `Microsoft.EntityFrameworkCore.Relational.Design` package has been removed.</span></span> <span data-ttu-id="2e404-204">Obsah byl konsolidován do `Microsoft.EntityFrameworkCore.Relational` a. `Microsoft.EntityFrameworkCore.Design`</span><span class="sxs-lookup"><span data-stu-id="2e404-204">It's contents were consolidated into `Microsoft.EntityFrameworkCore.Relational` and `Microsoft.EntityFrameworkCore.Design`.</span></span>

<span data-ttu-id="2e404-205">To se šíří do balíčků pro dobu návrhu zprostředkovatele.</span><span class="sxs-lookup"><span data-stu-id="2e404-205">This propagates into the provider design-time packages.</span></span> <span data-ttu-id="2e404-206">Balíčky (`Microsoft.EntityFrameworkCore.Sqlite.Design`, `Microsoft.EntityFrameworkCore.SqlServer.Design`atd.) se odebraly a jejich obsah se konsoliduje do hlavních balíčků poskytovatele.</span><span class="sxs-lookup"><span data-stu-id="2e404-206">Those packages (`Microsoft.EntityFrameworkCore.Sqlite.Design`, `Microsoft.EntityFrameworkCore.SqlServer.Design`, etc.) were removed and their contents consolidated into the main provider packages.</span></span>

<span data-ttu-id="2e404-207">Chcete- `Scaffold-DbContext` li `dotnet ef dbcontext scaffold` povolit nebo v EF Core 2,0, stačí pouze odkazovat na balíček s jedním zprostředkovatelem:</span><span class="sxs-lookup"><span data-stu-id="2e404-207">To enable `Scaffold-DbContext` or `dotnet ef dbcontext scaffold` in EF Core 2.0, you only need to reference the single provider package:</span></span>

``` xml
<PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer"
    Version="2.0.0" />
<PackageReference Include="Microsoft.EntityFrameworkCore.Tools"
    Version="2.0.0"
    PrivateAssets="All" />
<DotNetCliToolReference Include="Microsoft.EntityFrameworkCore.Tools.DotNet"
    Version="2.0.0" />
```
